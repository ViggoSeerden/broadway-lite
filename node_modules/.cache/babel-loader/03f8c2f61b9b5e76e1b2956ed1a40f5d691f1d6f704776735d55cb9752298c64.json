{"ast":null,"code":"var _nameToOperatorMap;\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport { get } from '../../../services/objects';\nimport { isString, isArray } from '../../../services/predicate';\nimport { eq, exact, gt, gte, lt, lte } from './operators';\nimport { AST } from './ast';\nvar EXPLAIN_FIELD = '__explain';\nvar nameToOperatorMap = (_nameToOperatorMap = {}, _defineProperty(_nameToOperatorMap, AST.Operator.EQ, eq), _defineProperty(_nameToOperatorMap, AST.Operator.EXACT, exact), _defineProperty(_nameToOperatorMap, AST.Operator.GT, gt), _defineProperty(_nameToOperatorMap, AST.Operator.GTE, gte), _defineProperty(_nameToOperatorMap, AST.Operator.LT, lt), _defineProperty(_nameToOperatorMap, AST.Operator.LTE, lte), _nameToOperatorMap);\nvar defaultIsClauseMatcher = function defaultIsClauseMatcher(item, clause, explain) {\n  var type = clause.type,\n    flag = clause.flag,\n    match = clause.match;\n  var value = get(item, clause.flag);\n  var must = AST.Match.isMustClause(clause);\n  var hit = !!value === must;\n  if (explain && hit) {\n    explain.push({\n      hit: hit,\n      type: type,\n      flag: flag,\n      match: match\n    });\n  }\n  return hit;\n};\nvar fieldClauseMatcher = function fieldClauseMatcher(item, field) {\n  var clauses = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var explain = arguments.length > 3 ? arguments[3] : undefined;\n  return clauses.every(function (clause) {\n    var type = clause.type,\n      value = clause.value,\n      match = clause.match;\n    var operator = nameToOperatorMap[clause.operator];\n    if (!operator) {\n      // unknown matcher\n      return true;\n    }\n    if (!AST.Match.isMust(match)) {\n      operator = function operator(value, token) {\n        return !nameToOperatorMap[clause.operator](value, token);\n      };\n    }\n    var itemValue = get(item, field);\n    var hit = isArray(value) ? value.some(function (v) {\n      return operator(itemValue, v);\n    }) : operator(itemValue, value);\n    if (explain && hit) {\n      explain.push({\n        hit: hit,\n        type: type,\n        field: field,\n        value: value,\n        match: match,\n        operator: operator\n      });\n    }\n    return hit;\n  });\n};\n\n// You might think that we could specify `item: T` here and do something\n// with `keyof`, but that wouldn't work with `nested.field.name`\nvar extractStringFieldsFromItem = function extractStringFieldsFromItem(item) {\n  return Object.keys(item).reduce(function (fields, key) {\n    if (isString(item[key])) {\n      fields.push(key);\n    }\n    return fields;\n  }, []);\n};\nvar termClauseMatcher = function termClauseMatcher(item, fields) {\n  var clauses = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var explain = arguments.length > 3 ? arguments[3] : undefined;\n  var searchableFields = fields || extractStringFieldsFromItem(item);\n  return clauses.every(function (clause) {\n    var type = clause.type,\n      value = clause.value,\n      match = clause.match;\n    var isMustClause = AST.Match.isMustClause(clause);\n    var equals = nameToOperatorMap[AST.Operator.EQ];\n    var containsMatches = searchableFields.some(function (field) {\n      var itemValue = get(item, field);\n      var isMatch = equals(itemValue, value);\n      if (explain) {\n        // If testing for the presence of a term, then we record a match as a match.\n        // If testing for the absence of a term, then we invert this logic: we record a\n        // non-match as a match.\n        var hit = isMustClause && isMatch || !isMustClause && !isMatch;\n        if (hit) {\n          explain.push({\n            hit: hit,\n            type: type,\n            field: field,\n            match: match,\n            value: value\n          });\n        }\n      }\n      return isMatch;\n    });\n    if (isMustClause) {\n      // If we're testing for the presence of a term, then we only need 1 field to match.\n      return containsMatches;\n    }\n\n    // If we're testing for the absence of a term, we can't have any matching fields at all.\n    return !containsMatches;\n  });\n};\nexport var createFilter = function createFilter(ast, defaultFields) {\n  var isClauseMatcher = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultIsClauseMatcher;\n  var explain = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  // Return items which pass ALL conditions: matches the terms entered, the specified field values,\n  // and the specified \"is\" clauses.\n  return function (item) {\n    var explainLines = explain ? [] : undefined;\n    if (explainLines) {\n      // @ts-ignore technically, we could require T to extend `{ __explain?: Explain[] }` but that seems\n      // like a ridiculous requirement on the caller.\n      item[EXPLAIN_FIELD] = explainLines;\n    }\n    var termClauses = ast.getTermClauses();\n    var fields = ast.getFieldNames();\n    var isClauses = ast.getIsClauses();\n    var groupClauses = ast.getGroupClauses();\n    var isTermMatch = termClauseMatcher(item, defaultFields, termClauses, explainLines);\n    if (!isTermMatch) {\n      return false;\n    }\n    var isFieldsMatch = fields.every(function (field) {\n      return fieldClauseMatcher(item, field, ast.getFieldClauses(field), explainLines);\n    });\n    if (!isFieldsMatch) {\n      return false;\n    }\n    var isIsMatch = isClauses.every(function (clause) {\n      return isClauseMatcher(item, clause, explainLines);\n    });\n    if (!isIsMatch) {\n      return false;\n    }\n    var isGroupMatch = groupClauses.every(function (clause) {\n      var matchesGroup = clause.value.some(function (clause) {\n        if (AST.Term.isInstance(clause)) {\n          return termClauseMatcher(item, defaultFields, [clause], explainLines);\n        }\n        if (AST.Field.isInstance(clause)) {\n          return fieldClauseMatcher(item, clause.field, [clause], explainLines);\n        }\n        if (AST.Is.isInstance(clause)) {\n          return isClauseMatcher(item, clause, explainLines);\n        }\n        throw new Error(\"Unknown query clause type in group, [\".concat(clause.type, \"]\"));\n      });\n      return AST.Match.isMustClause(clause) ? matchesGroup : !matchesGroup;\n    });\n    return isGroupMatch;\n  };\n};\nexport function executeAst(ast, items) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var isClauseMatcher = options.isClauseMatcher,\n    defaultFields = options.defaultFields,\n    explain = options.explain;\n  var filter = createFilter(ast, defaultFields, isClauseMatcher, explain);\n  return items.filter(filter);\n}","map":{"version":3,"names":["_nameToOperatorMap","_typeof","obj","Symbol","iterator","constructor","prototype","_defineProperty","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","call","TypeError","Number","get","isString","isArray","eq","exact","gt","gte","lt","lte","AST","EXPLAIN_FIELD","nameToOperatorMap","Operator","EQ","EXACT","GT","GTE","LT","LTE","defaultIsClauseMatcher","item","clause","explain","type","flag","match","must","Match","isMustClause","hit","push","fieldClauseMatcher","field","clauses","arguments","length","every","operator","isMust","token","itemValue","some","v","extractStringFieldsFromItem","keys","reduce","fields","termClauseMatcher","searchableFields","equals","containsMatches","isMatch","createFilter","ast","defaultFields","isClauseMatcher","explainLines","termClauses","getTermClauses","getFieldNames","isClauses","getIsClauses","groupClauses","getGroupClauses","isTermMatch","isFieldsMatch","getFieldClauses","isIsMatch","isGroupMatch","matchesGroup","Term","isInstance","Field","Is","Error","concat","executeAst","items","options","filter"],"sources":["/home/runner/work/broadway-lite/broadway-lite/node_modules/@elastic/eui/es/components/search_bar/query/execute_ast.js"],"sourcesContent":["var _nameToOperatorMap;\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport { get } from '../../../services/objects';\nimport { isString, isArray } from '../../../services/predicate';\nimport { eq, exact, gt, gte, lt, lte } from './operators';\nimport { AST } from './ast';\nvar EXPLAIN_FIELD = '__explain';\nvar nameToOperatorMap = (_nameToOperatorMap = {}, _defineProperty(_nameToOperatorMap, AST.Operator.EQ, eq), _defineProperty(_nameToOperatorMap, AST.Operator.EXACT, exact), _defineProperty(_nameToOperatorMap, AST.Operator.GT, gt), _defineProperty(_nameToOperatorMap, AST.Operator.GTE, gte), _defineProperty(_nameToOperatorMap, AST.Operator.LT, lt), _defineProperty(_nameToOperatorMap, AST.Operator.LTE, lte), _nameToOperatorMap);\nvar defaultIsClauseMatcher = function defaultIsClauseMatcher(item, clause, explain) {\n  var type = clause.type,\n    flag = clause.flag,\n    match = clause.match;\n  var value = get(item, clause.flag);\n  var must = AST.Match.isMustClause(clause);\n  var hit = !!value === must;\n  if (explain && hit) {\n    explain.push({\n      hit: hit,\n      type: type,\n      flag: flag,\n      match: match\n    });\n  }\n  return hit;\n};\nvar fieldClauseMatcher = function fieldClauseMatcher(item, field) {\n  var clauses = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var explain = arguments.length > 3 ? arguments[3] : undefined;\n  return clauses.every(function (clause) {\n    var type = clause.type,\n      value = clause.value,\n      match = clause.match;\n    var operator = nameToOperatorMap[clause.operator];\n    if (!operator) {\n      // unknown matcher\n      return true;\n    }\n    if (!AST.Match.isMust(match)) {\n      operator = function operator(value, token) {\n        return !nameToOperatorMap[clause.operator](value, token);\n      };\n    }\n    var itemValue = get(item, field);\n    var hit = isArray(value) ? value.some(function (v) {\n      return operator(itemValue, v);\n    }) : operator(itemValue, value);\n    if (explain && hit) {\n      explain.push({\n        hit: hit,\n        type: type,\n        field: field,\n        value: value,\n        match: match,\n        operator: operator\n      });\n    }\n    return hit;\n  });\n};\n\n// You might think that we could specify `item: T` here and do something\n// with `keyof`, but that wouldn't work with `nested.field.name`\nvar extractStringFieldsFromItem = function extractStringFieldsFromItem(item) {\n  return Object.keys(item).reduce(function (fields, key) {\n    if (isString(item[key])) {\n      fields.push(key);\n    }\n    return fields;\n  }, []);\n};\nvar termClauseMatcher = function termClauseMatcher(item, fields) {\n  var clauses = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var explain = arguments.length > 3 ? arguments[3] : undefined;\n  var searchableFields = fields || extractStringFieldsFromItem(item);\n  return clauses.every(function (clause) {\n    var type = clause.type,\n      value = clause.value,\n      match = clause.match;\n    var isMustClause = AST.Match.isMustClause(clause);\n    var equals = nameToOperatorMap[AST.Operator.EQ];\n    var containsMatches = searchableFields.some(function (field) {\n      var itemValue = get(item, field);\n      var isMatch = equals(itemValue, value);\n      if (explain) {\n        // If testing for the presence of a term, then we record a match as a match.\n        // If testing for the absence of a term, then we invert this logic: we record a\n        // non-match as a match.\n        var hit = isMustClause && isMatch || !isMustClause && !isMatch;\n        if (hit) {\n          explain.push({\n            hit: hit,\n            type: type,\n            field: field,\n            match: match,\n            value: value\n          });\n        }\n      }\n      return isMatch;\n    });\n    if (isMustClause) {\n      // If we're testing for the presence of a term, then we only need 1 field to match.\n      return containsMatches;\n    }\n\n    // If we're testing for the absence of a term, we can't have any matching fields at all.\n    return !containsMatches;\n  });\n};\nexport var createFilter = function createFilter(ast, defaultFields) {\n  var isClauseMatcher = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultIsClauseMatcher;\n  var explain = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  // Return items which pass ALL conditions: matches the terms entered, the specified field values,\n  // and the specified \"is\" clauses.\n  return function (item) {\n    var explainLines = explain ? [] : undefined;\n    if (explainLines) {\n      // @ts-ignore technically, we could require T to extend `{ __explain?: Explain[] }` but that seems\n      // like a ridiculous requirement on the caller.\n      item[EXPLAIN_FIELD] = explainLines;\n    }\n    var termClauses = ast.getTermClauses();\n    var fields = ast.getFieldNames();\n    var isClauses = ast.getIsClauses();\n    var groupClauses = ast.getGroupClauses();\n    var isTermMatch = termClauseMatcher(item, defaultFields, termClauses, explainLines);\n    if (!isTermMatch) {\n      return false;\n    }\n    var isFieldsMatch = fields.every(function (field) {\n      return fieldClauseMatcher(item, field, ast.getFieldClauses(field), explainLines);\n    });\n    if (!isFieldsMatch) {\n      return false;\n    }\n    var isIsMatch = isClauses.every(function (clause) {\n      return isClauseMatcher(item, clause, explainLines);\n    });\n    if (!isIsMatch) {\n      return false;\n    }\n    var isGroupMatch = groupClauses.every(function (clause) {\n      var matchesGroup = clause.value.some(function (clause) {\n        if (AST.Term.isInstance(clause)) {\n          return termClauseMatcher(item, defaultFields, [clause], explainLines);\n        }\n        if (AST.Field.isInstance(clause)) {\n          return fieldClauseMatcher(item, clause.field, [clause], explainLines);\n        }\n        if (AST.Is.isInstance(clause)) {\n          return isClauseMatcher(item, clause, explainLines);\n        }\n        throw new Error(\"Unknown query clause type in group, [\".concat(clause.type, \"]\"));\n      });\n      return AST.Match.isMustClause(clause) ? matchesGroup : !matchesGroup;\n    });\n    return isGroupMatch;\n  };\n};\nexport function executeAst(ast, items) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var isClauseMatcher = options.isClauseMatcher,\n    defaultFields = options.defaultFields,\n    explain = options.explain;\n  var filter = createFilter(ast, defaultFields, isClauseMatcher, explain);\n  return items.filter(filter);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
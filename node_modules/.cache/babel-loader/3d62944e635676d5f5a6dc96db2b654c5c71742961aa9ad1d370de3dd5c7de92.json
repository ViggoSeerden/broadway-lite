{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nexport var POSITIONS = ['top', 'right', 'bottom', 'left'];\nvar relatedDimension = {\n  top: 'height',\n  right: 'width',\n  bottom: 'height',\n  left: 'width'\n};\nvar dimensionPositionAttribute = {\n  height: 'top',\n  width: 'left'\n};\nvar positionComplements = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right'\n};\n\n// always resolving to top/left is taken advantage of by knowing they are the\n// minimum edges of the bounding box\nvar positionSubstitutes = {\n  top: 'left',\n  right: 'top',\n  bottom: 'left',\n  left: 'top'\n};\nvar getBufferValues = function getBufferValues(buffer) {\n  if (Array.isArray(buffer)) {\n    var _buffer = _slicedToArray(buffer, 4),\n      topBuffer = _buffer[0],\n      rightBuffer = _buffer[1],\n      bottomBuffer = _buffer[2],\n      leftBuffer = _buffer[3];\n    return [topBuffer, rightBuffer, bottomBuffer, leftBuffer];\n  }\n  return [buffer, buffer, buffer, buffer];\n};\n\n/**\n * Calculates the absolute positioning (relative to document.body) to place a popover element\n *\n * @param anchor {HTMLElement} Element to anchor the popover to\n * @param popover {HTMLElement} Element containing the popover content\n * @param position {string} Position the user wants. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [forcePosition] {boolean} If true, use only the provided `position` value and don't try any other position\n * @param [align] {string} Cross-axis alignment. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [buffer=16] {number} Minimum distance between the popover and the bounding container\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [allowCrossAxis=true] {boolean} Whether to allow the popover to be positioned on the cross-axis\n * @param [container] {HTMLElement} Element the popover must be constrained to fit within\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If\n *  present, describes the size & constraints for an arrow element, and the\n *  function return value will include an `arrow` param with position details\n *\n * @returns {FindPopoverPositionResult} absolute page coordinates for the\n * popover, and the placement's relation to the anchor or undefined\n * there's no room.\n */\nexport function findPopoverPosition(_ref) {\n  var anchor = _ref.anchor,\n    popover = _ref.popover,\n    align = _ref.align,\n    position = _ref.position,\n    forcePosition = _ref.forcePosition,\n    _ref$buffer = _ref.buffer,\n    buffer = _ref$buffer === void 0 ? 16 : _ref$buffer,\n    _ref$offset = _ref.offset,\n    offset = _ref$offset === void 0 ? 0 : _ref$offset,\n    _ref$allowCrossAxis = _ref.allowCrossAxis,\n    allowCrossAxis = _ref$allowCrossAxis === void 0 ? true : _ref$allowCrossAxis,\n    container = _ref.container,\n    arrowConfig = _ref.arrowConfig,\n    returnBoundingBox = _ref.returnBoundingBox;\n  // find the screen-relative bounding boxes of the anchor, popover, and container\n  var anchorBoundingBox = getElementBoundingBox(anchor);\n  var popoverBoundingBox = getElementBoundingBox(popover);\n\n  // calculate the window's bounds\n  // window.(innerWidth|innerHeight) do not account for scrollbars\n  // so prefer the clientWidth/clientHeight of the DOM if available\n  var documentWidth = document.documentElement.clientWidth || window.innerWidth;\n  var documentHeight = document.documentElement.clientHeight || window.innerHeight;\n  var windowBoundingBox = {\n    top: 0,\n    right: documentWidth,\n    bottom: documentHeight,\n    left: 0,\n    height: documentHeight,\n    width: documentWidth\n  };\n\n  // if no container element is given fall back to using the window viewport\n  var containerBoundingBox = container ? getElementBoundingBox(container) : windowBoundingBox;\n\n  /**\n   * `position` was specified by the function caller and is a strong hint\n   * as to the preferred location of the popover relative to the anchor.\n   * However, we strongly prefer showing all of the popover content within\n   * the window+container boundary and will iterate over the four\n   * possible sides until a perfect fit is located. If none of the locations\n   * fully contain popover, the location with the best fit is selected.\n   *\n   * This approach first checks the preferred `position`, then its opposite\n   * along the same axis, next a location on the cross-axis, and finally it\n   * tests the remaining position.\n   *\n   * e.g.\n   * if position = \"top\" the order is top, bottom, left right\n   * if position = \"right\" the order is right, left, top, bottom\n   */\n\n  // Try the user-desired position first.\n  var iterationPositions = [position];\n  // keep user-defined alignment in the original positions.\n  var iterationAlignments = [align];\n  if (forcePosition !== true) {\n    iterationPositions.push(positionComplements[position]); // Try the complementary position.\n    iterationAlignments.push(align); // keep user-defined alignment in the complementary position.\n\n    if (allowCrossAxis) {\n      iterationPositions.push(positionSubstitutes[position],\n      // Switch to the cross axis.\n      positionComplements[positionSubstitutes[position]] // Try the complementary position on the cross axis.\n      );\n      iterationAlignments.push(undefined, undefined); // discard desired alignment on cross-axis\n    }\n  } else {\n    // position is forced, if it conflicts with the alignment then reset align to `null`\n    // e.g. original placement request for `downLeft` is moved to the `left` side, future calls\n    // will position and align `left`, and `leftLeft` is not a valid placement\n    if (position === align || align !== undefined && position === positionComplements[align]) {\n      iterationAlignments[0] = undefined;\n    }\n  }\n  var bestFit = undefined;\n  var bestPosition = null;\n  for (var idx = 0; idx < iterationPositions.length; idx++) {\n    var iterationPosition = iterationPositions[idx];\n\n    // See if we can find a position with a better fit than we've found so far.\n    var screenCoordinates = getPopoverScreenCoordinates({\n      position: iterationPosition,\n      align: iterationAlignments[idx],\n      anchorBoundingBox: anchorBoundingBox,\n      popoverBoundingBox: popoverBoundingBox,\n      windowBoundingBox: windowBoundingBox,\n      containerBoundingBox: containerBoundingBox,\n      offset: offset,\n      buffer: buffer,\n      arrowConfig: arrowConfig\n    });\n    if (bestFit === undefined || screenCoordinates.fit > bestFit) {\n      bestFit = screenCoordinates.fit;\n      bestPosition = {\n        fit: screenCoordinates.fit,\n        position: iterationPosition,\n        top: screenCoordinates.top + window.pageYOffset,\n        left: screenCoordinates.left + window.pageXOffset,\n        arrow: screenCoordinates.arrow\n      };\n\n      // If we've already found the ideal fit, use that position.\n      if (bestFit === 1) {\n        break;\n      }\n    }\n\n    // If we haven't improved the fit, then continue on and try a new position.\n  }\n  if (bestPosition == null) {\n    throw new Error('Failed to calculate bestPosition');\n  }\n  if (returnBoundingBox) {\n    bestPosition.anchorBoundingBox = anchorBoundingBox;\n  }\n  return bestPosition;\n}\n/**\n * Given a target position and the popover's surrounding context, returns either an\n * object with {top, left} screen coordinates or `null` if it's not possible to show\n * content in the target position\n * @param position {string} the target position, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param align {string} target alignment on the cross-axis, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param anchorBoundingBox {Object} bounding box of the anchor element\n * @param popoverBoundingBox {Object} bounding box of the popover element\n * @param windowBoundingBox {Object} bounding box of the window\n * @param containerBoundingBox {Object} bounding box of the container\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If present, describes the size &\n *  constraints for an arrow element, and the function return value will include an `arrow` param\n *  with position details\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [buffer=0] {number} Minimum distance between the popover's\n *  placement and the container edge\n *\n * @returns {GetPopoverScreenCoordinatesResult}\n *  object with top/left coordinates, the popover's relative position to the anchor, and how well the\n *  popover fits in the location (0.0 -> 1.0) coordinates and the popover's relative position, if\n *  there is no room in this placement then null\n */\nexport function getPopoverScreenCoordinates(_ref2) {\n  var _popoverPlacement, _ref3;\n  var position = _ref2.position,\n    align = _ref2.align,\n    anchorBoundingBox = _ref2.anchorBoundingBox,\n    popoverBoundingBox = _ref2.popoverBoundingBox,\n    windowBoundingBox = _ref2.windowBoundingBox,\n    containerBoundingBox = _ref2.containerBoundingBox,\n    arrowConfig = _ref2.arrowConfig,\n    _ref2$offset = _ref2.offset,\n    offset = _ref2$offset === void 0 ? 0 : _ref2$offset,\n    _ref2$buffer = _ref2.buffer,\n    buffer = _ref2$buffer === void 0 ? 0 : _ref2$buffer;\n  /**\n   * The goal is to find the best way to align the popover content\n   * on the given side of the anchor element. The popover prefers\n   * centering on the anchor but can shift along the cross-axis as needed.\n   *\n   * We return the top/left coordinates that best fit the popover inside\n   * the given boundaries, and also return the `fit` value which indicates\n   * what percentage of the popover is within the bounds.\n   *\n   * e.g. finding a location when position=top\n   * the preferred location is directly over the anchor\n   *\n   *        +----------------------+\n   *        |       popover        |\n   *        +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   * but if anchor doesn't have much (or any) room on its ride side\n   * the popover will shift to the left\n   *\n   *    +----------------------+\n   *    |       popover        |\n   *    +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   */\n\n  var crossAxisFirstSide = positionSubstitutes[position]; // \"top\" -> \"left\"\n  var crossAxisSecondSide = positionComplements[crossAxisFirstSide]; // \"left\" -> \"right\"\n  var crossAxisDimension = relatedDimension[crossAxisFirstSide]; // \"left\" -> \"width\"\n\n  var _getBufferValues = getBufferValues(buffer),\n    _getBufferValues2 = _slicedToArray(_getBufferValues, 4),\n    topBuffer = _getBufferValues2[0],\n    rightBuffer = _getBufferValues2[1],\n    bottomBuffer = _getBufferValues2[2],\n    leftBuffer = _getBufferValues2[3];\n  var _getCrossAxisPosition = getCrossAxisPosition({\n      crossAxisFirstSide: crossAxisFirstSide,\n      crossAxisSecondSide: crossAxisSecondSide,\n      crossAxisDimension: crossAxisDimension,\n      position: position,\n      align: align,\n      buffer: buffer,\n      offset: offset,\n      windowBoundingBox: windowBoundingBox,\n      containerBoundingBox: containerBoundingBox,\n      popoverBoundingBox: popoverBoundingBox,\n      anchorBoundingBox: anchorBoundingBox,\n      arrowConfig: arrowConfig\n    }),\n    crossAxisPosition = _getCrossAxisPosition.crossAxisPosition,\n    crossAxisArrowPosition = _getCrossAxisPosition.crossAxisArrowPosition;\n  var primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n  var primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  var _getPrimaryAxisPositi = getPrimaryAxisPosition({\n      position: position,\n      offset: offset,\n      popoverBoundingBox: popoverBoundingBox,\n      anchorBoundingBox: anchorBoundingBox,\n      arrowConfig: arrowConfig\n    }),\n    primaryAxisPosition = _getPrimaryAxisPositi.primaryAxisPosition,\n    primaryAxisArrowPosition = _getPrimaryAxisPositi.primaryAxisArrowPosition;\n  var popoverPlacement = (_popoverPlacement = {}, _defineProperty(_popoverPlacement, crossAxisFirstSide, crossAxisPosition), _defineProperty(_popoverPlacement, primaryAxisPositionName, primaryAxisPosition), _popoverPlacement);\n\n  // calculate the fit of the popover in this location\n  // fit is in range 0.0 -> 1.0 and is the percentage of the popover which is visible in this location\n  var combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox);\n\n  // shrink the visible bounding box by `buffer`\n  // to compute a fit value\n  combinedBoundingBox.top += topBuffer;\n  combinedBoundingBox.right -= rightBuffer;\n  combinedBoundingBox.bottom -= bottomBuffer;\n  combinedBoundingBox.left += leftBuffer;\n  var fit = getVisibleFit({\n    top: popoverPlacement.top,\n    right: popoverPlacement.left + popoverBoundingBox.width,\n    bottom: popoverPlacement.top + popoverBoundingBox.height,\n    left: popoverPlacement.left,\n    width: popoverBoundingBox.width,\n    height: popoverBoundingBox.height\n  }, combinedBoundingBox);\n  var arrow = arrowConfig ? (_ref3 = {}, _defineProperty(_ref3, crossAxisFirstSide, crossAxisArrowPosition - popoverPlacement[crossAxisFirstSide]), _defineProperty(_ref3, primaryAxisPositionName, primaryAxisArrowPosition), _ref3) : undefined;\n  return {\n    fit: fit,\n    top: popoverPlacement.top,\n    left: popoverPlacement.left,\n    arrow: arrow ? {\n      left: arrow.left,\n      top: arrow.top\n    } : undefined\n  };\n}\nfunction getCrossAxisPosition(_ref4) {\n  var crossAxisFirstSide = _ref4.crossAxisFirstSide,\n    crossAxisSecondSide = _ref4.crossAxisSecondSide,\n    crossAxisDimension = _ref4.crossAxisDimension,\n    position = _ref4.position,\n    align = _ref4.align,\n    buffer = _ref4.buffer,\n    offset = _ref4.offset,\n    windowBoundingBox = _ref4.windowBoundingBox,\n    containerBoundingBox = _ref4.containerBoundingBox,\n    popoverBoundingBox = _ref4.popoverBoundingBox,\n    anchorBoundingBox = _ref4.anchorBoundingBox,\n    arrowConfig = _ref4.arrowConfig;\n  // how much of the popover overflows past either side of the anchor if its centered\n  var popoverSizeOnCrossAxis = popoverBoundingBox[crossAxisDimension];\n  var anchorSizeOnCrossAxis = anchorBoundingBox[crossAxisDimension];\n  var anchorHalfSize = anchorSizeOnCrossAxis / 2;\n\n  // the popover's original position on the cross-axis is determined by:\n  var crossAxisPositionOriginal = anchorBoundingBox[crossAxisFirstSide] +\n  // where the anchor is located\n  anchorHalfSize -\n  // plus half anchor dimension\n  popoverSizeOnCrossAxis / 2; // less half the popover dimension\n\n  // To fit the content within both the window and container,\n  // compute the smaller of the two spaces along each edge\n  var combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox);\n  var availableSpace = getAvailableSpace(anchorBoundingBox, combinedBoundingBox, buffer, offset, position);\n  var minimumSpace = arrowConfig ? arrowConfig.arrowBuffer : 0;\n  var contentOverflowSize = (popoverSizeOnCrossAxis - anchorSizeOnCrossAxis) / 2;\n  var alignAmount = 0;\n  var alignDirection = 1;\n  var amountOfShiftNeeded = 0;\n  var shiftDirection = 1;\n  if (align != null) {\n    // no alignment, find how much the container boundary requires the content to shift\n    alignDirection = align === 'top' || align === 'left' ? 1 : -1;\n    alignAmount = contentOverflowSize;\n    var alignedOverflowAmount = contentOverflowSize + alignAmount;\n    var needsShift = alignedOverflowAmount > availableSpace[positionComplements[align]];\n    amountOfShiftNeeded = needsShift ? alignedOverflowAmount - availableSpace[positionComplements[align]] : 0;\n    shiftDirection = -1 * alignDirection;\n  } else {\n    // shifting the popover to one side may yield a better fit\n    var spaceAvailableOnFirstSide = availableSpace[crossAxisFirstSide];\n    var spaceAvailableOnSecondSide = availableSpace[crossAxisSecondSide];\n    var isShiftTowardFirstSide = spaceAvailableOnFirstSide > spaceAvailableOnSecondSide;\n    shiftDirection = isShiftTowardFirstSide ? -1 : 1;\n\n    // determine which direction has more room and the popover should shift to\n    var leastAvailableSpace = Math.min(spaceAvailableOnFirstSide, spaceAvailableOnSecondSide);\n    var _needsShift = contentOverflowSize > leastAvailableSpace;\n    amountOfShiftNeeded = _needsShift ? contentOverflowSize - leastAvailableSpace : 0;\n  }\n\n  // shift over the popover if necessary\n  var shiftAmount = amountOfShiftNeeded * shiftDirection;\n  var crossAxisPosition = crossAxisPositionOriginal + shiftAmount + alignAmount * alignDirection;\n\n  // if an `arrowConfig` is specified, find where to position the arrow\n  var crossAxisArrowPosition;\n  if (arrowConfig) {\n    var arrowWidth = arrowConfig.arrowWidth;\n    crossAxisArrowPosition = anchorBoundingBox[crossAxisFirstSide] + anchorHalfSize - arrowWidth / 2;\n\n    // make sure there's enough buffer around the arrow\n    // by calculating how how much the arrow would need to move\n    // but instead of moving the arrow, shift the popover content\n    if (crossAxisArrowPosition < crossAxisPosition + minimumSpace) {\n      // arrow is too close to the minimum side\n      var difference = crossAxisPosition + minimumSpace - crossAxisArrowPosition;\n      crossAxisPosition -= difference;\n    } else if (crossAxisArrowPosition + minimumSpace + arrowWidth > crossAxisPosition + popoverSizeOnCrossAxis) {\n      // arrow is too close to the maximum side\n      var edge = crossAxisPosition + popoverSizeOnCrossAxis;\n      var _difference = crossAxisArrowPosition - (edge - minimumSpace - arrowWidth);\n      crossAxisPosition += _difference;\n    }\n  }\n  return {\n    crossAxisPosition: crossAxisPosition,\n    crossAxisArrowPosition: crossAxisArrowPosition\n  };\n}\nfunction getPrimaryAxisPosition(_ref5) {\n  var position = _ref5.position,\n    offset = _ref5.offset,\n    popoverBoundingBox = _ref5.popoverBoundingBox,\n    anchorBoundingBox = _ref5.anchorBoundingBox,\n    arrowConfig = _ref5.arrowConfig;\n  // if positioning to the top or left, the target position decreases\n  // from the anchor's top or left, otherwise the position adds to the anchor's\n  var isOffsetDecreasing = position === 'top' || position === 'left';\n  var primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n  var popoverSizeOnPrimaryAxis = popoverBoundingBox[primaryAxisDimension];\n\n  // start at the top or left edge of the anchor element\n  var primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n  var anchorEdgeOrigin = anchorBoundingBox[primaryAxisPositionName];\n\n  // find the popover position on the primary axis\n  var anchorSizeOnPrimaryAxis = anchorBoundingBox[primaryAxisDimension];\n  var primaryAxisOffset = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : anchorSizeOnPrimaryAxis;\n  var contentOffset = (offset + primaryAxisOffset) * (isOffsetDecreasing ? -1 : 1);\n  var primaryAxisPosition = anchorEdgeOrigin + contentOffset;\n  var primaryAxisArrowPosition;\n  if (arrowConfig) {\n    primaryAxisArrowPosition = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : 0;\n  }\n  return {\n    primaryAxisPosition: primaryAxisPosition,\n    primaryAxisArrowPosition: primaryAxisArrowPosition\n  };\n}\n\n/**\n * Finds the client pixel coordinate of each edge for the element's bounding box,\n * and the bounding box's width & height\n *\n * @param {HTMLElement} element\n * @returns {{top: number, right: number, bottom: number, left: number, height: number, width: number}}\n */\nexport function getElementBoundingBox(element) {\n  var rect = element.getBoundingClientRect();\n  return {\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    height: rect.height,\n    width: rect.width\n  };\n}\n\n/**\n * Calculates the available content space between anchor and container\n *\n * @param {Object} anchorBoundingBox Client bounding box of the anchor element\n * @param {Object} containerBoundingBox Client bounding box of the container element\n * @param {number} buffer Minimum distance between the popover and the bounding container\n * @param {number} offset Distance between the popover and the anchor\n * @param {string} offsetSide Side the offset needs to be applied to, one\n *  of [\"top\", \"right\", \"bottom\", \"left\"]\n * @returns {{top: number, right: number, bottom: number, left: number}}\n */\nexport function getAvailableSpace(anchorBoundingBox, containerBoundingBox, buffer, offset, offsetSide) {\n  var _getBufferValues3 = getBufferValues(buffer),\n    _getBufferValues4 = _slicedToArray(_getBufferValues3, 4),\n    topBuffer = _getBufferValues4[0],\n    rightBuffer = _getBufferValues4[1],\n    bottomBuffer = _getBufferValues4[2],\n    leftBuffer = _getBufferValues4[3];\n  return {\n    top: anchorBoundingBox.top - containerBoundingBox.top - topBuffer - (offsetSide === 'top' ? offset : 0),\n    right: containerBoundingBox.right - anchorBoundingBox.right - rightBuffer - (offsetSide === 'right' ? offset : 0),\n    bottom: containerBoundingBox.bottom - anchorBoundingBox.bottom - bottomBuffer - (offsetSide === 'bottom' ? offset : 0),\n    left: anchorBoundingBox.left - containerBoundingBox.left - leftBuffer - (offsetSide === 'left' ? offset : 0)\n  };\n}\n\n/**\n * Computes the fit (overlap) of the content within the container, fit is in range 0.0 => 1.0\n * @param contentBoundingBox bounding box of content to calculate fit for\n * @param containerBoundingBox bounding box of container\n * @returns {number}\n */\nexport function getVisibleFit(contentBoundingBox, containerBoundingBox) {\n  var intersection = intersectBoundingBoxes(contentBoundingBox, containerBoundingBox);\n  if (intersection.left > intersection.right || intersection.top > intersection.top) {\n    // there is no intersection, the boxes are completely separated on at least one axis\n    return 0;\n  }\n  var intersectionArea = (intersection.right - intersection.left) * (intersection.bottom - intersection.top);\n  var contentArea = (contentBoundingBox.right - contentBoundingBox.left) * (contentBoundingBox.bottom - contentBoundingBox.top);\n  return intersectionArea / contentArea;\n}\n\n/**\n * Calculates the intersection space between two bounding boxes\n *\n * @param firstBox\n * @param secondBox\n * @returns {EuiClientRect}\n */\nexport function intersectBoundingBoxes(firstBox, secondBox) {\n  var top = Math.max(firstBox.top, secondBox.top);\n  var right = Math.min(firstBox.right, secondBox.right);\n  var bottom = Math.min(firstBox.bottom, secondBox.bottom);\n  var left = Math.max(firstBox.left, secondBox.left);\n  var height = Math.max(bottom - top, 0);\n  var width = Math.max(right - left, 0);\n  return {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left,\n    height: height,\n    width: width\n  };\n}\n\n/**\n * Returns the top-most defined z-index in the element's ancestor hierarchy\n * relative to the `target` element; if no z-index is defined, returns 0\n * @param element {HTMLElement}\n * @param cousin {HTMLElement}\n * @returns {number}\n */\nexport function getElementZIndex(element, cousin) {\n  /**\n   * finding the z-index of `element` is not the full story\n   * its the CSS stacking context that is important\n   * take this DOM for example:\n   * body\n   *   section[z-index: 1000]\n   *     p[z-index: 500]\n   *       button\n   *   div\n   *\n   * what z-index does the `div` need to display next to `button`?\n   * the `div` and `section` are where the stacking context splits\n   * so `div` needs to copy `section`'s z-index in order to\n   * appear next to / over `button`\n   *\n   * calculate this by starting at `button` and finding its offsetParents\n   * then walk the parents from top -> down until the stacking context\n   * split is found, or if there is no split then a specific z-index is unimportant\n   */\n\n  // build the array of the element + its offset parents\n  var nodesToInspect = [];\n  while (true) {\n    nodesToInspect.push(element);\n\n    // AFAICT this is a valid cast - the libdefs appear wrong\n    element = element.offsetParent;\n\n    // stop if there is no parent\n    if (element == null) {\n      break;\n    }\n\n    // stop if the parent contains the related element\n    // as this is the z-index ancestor\n    if (element.contains(cousin)) {\n      break;\n    }\n  }\n\n  // reverse the nodes to walk from top -> element\n  nodesToInspect.reverse();\n  for (var _i2 = 0, _nodesToInspect = nodesToInspect; _i2 < _nodesToInspect.length; _i2++) {\n    var node = _nodesToInspect[_i2];\n    // get this node's z-index css value\n    var zIndex = window.document.defaultView.getComputedStyle(node).getPropertyValue('z-index');\n\n    // if the z-index is not a number (e.g. \"auto\") return null, else the value\n    var parsedZIndex = parseInt(zIndex, 10);\n    if (!isNaN(parsedZIndex)) {\n      return parsedZIndex;\n    }\n  }\n  return 0;\n}","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_defineProperty","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","call","TypeError","Number","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","o","minLen","_arrayLikeToArray","n","toString","slice","name","Array","from","test","len","length","arr2","_i","_s","_e","_x","_r","_arr","_n","_d","next","done","push","err","return","isArray","POSITIONS","relatedDimension","top","right","bottom","left","dimensionPositionAttribute","height","width","positionComplements","positionSubstitutes","getBufferValues","buffer","_buffer","topBuffer","rightBuffer","bottomBuffer","leftBuffer","findPopoverPosition","_ref","anchor","popover","align","position","forcePosition","_ref$buffer","_ref$offset","offset","_ref$allowCrossAxis","allowCrossAxis","container","arrowConfig","returnBoundingBox","anchorBoundingBox","getElementBoundingBox","popoverBoundingBox","documentWidth","document","documentElement","clientWidth","window","innerWidth","documentHeight","clientHeight","innerHeight","windowBoundingBox","containerBoundingBox","iterationPositions","iterationAlignments","bestFit","bestPosition","idx","iterationPosition","screenCoordinates","getPopoverScreenCoordinates","fit","pageYOffset","pageXOffset","arrow","Error","_ref2","_popoverPlacement","_ref3","_ref2$offset","_ref2$buffer","crossAxisFirstSide","crossAxisSecondSide","crossAxisDimension","_getBufferValues","_getBufferValues2","_getCrossAxisPosition","getCrossAxisPosition","crossAxisPosition","crossAxisArrowPosition","primaryAxisDimension","primaryAxisPositionName","_getPrimaryAxisPositi","getPrimaryAxisPosition","primaryAxisPosition","primaryAxisArrowPosition","popoverPlacement","combinedBoundingBox","intersectBoundingBoxes","getVisibleFit","_ref4","popoverSizeOnCrossAxis","anchorSizeOnCrossAxis","anchorHalfSize","crossAxisPositionOriginal","availableSpace","getAvailableSpace","minimumSpace","arrowBuffer","contentOverflowSize","alignAmount","alignDirection","amountOfShiftNeeded","shiftDirection","alignedOverflowAmount","needsShift","spaceAvailableOnFirstSide","spaceAvailableOnSecondSide","isShiftTowardFirstSide","leastAvailableSpace","Math","min","_needsShift","shiftAmount","arrowWidth","difference","edge","_difference","_ref5","isOffsetDecreasing","popoverSizeOnPrimaryAxis","anchorEdgeOrigin","anchorSizeOnPrimaryAxis","primaryAxisOffset","contentOffset","element","rect","getBoundingClientRect","offsetSide","_getBufferValues3","_getBufferValues4","contentBoundingBox","intersection","intersectionArea","contentArea","firstBox","secondBox","max","getElementZIndex","cousin","nodesToInspect","offsetParent","contains","reverse","_i2","_nodesToInspect","node","zIndex","defaultView","getComputedStyle","getPropertyValue","parsedZIndex","parseInt","isNaN"],"sources":["/home/runner/work/broadway-lite/broadway-lite/node_modules/@elastic/eui/es/services/popover/popover_positioning.js"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nexport var POSITIONS = ['top', 'right', 'bottom', 'left'];\nvar relatedDimension = {\n  top: 'height',\n  right: 'width',\n  bottom: 'height',\n  left: 'width'\n};\nvar dimensionPositionAttribute = {\n  height: 'top',\n  width: 'left'\n};\nvar positionComplements = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right'\n};\n\n// always resolving to top/left is taken advantage of by knowing they are the\n// minimum edges of the bounding box\nvar positionSubstitutes = {\n  top: 'left',\n  right: 'top',\n  bottom: 'left',\n  left: 'top'\n};\nvar getBufferValues = function getBufferValues(buffer) {\n  if (Array.isArray(buffer)) {\n    var _buffer = _slicedToArray(buffer, 4),\n      topBuffer = _buffer[0],\n      rightBuffer = _buffer[1],\n      bottomBuffer = _buffer[2],\n      leftBuffer = _buffer[3];\n    return [topBuffer, rightBuffer, bottomBuffer, leftBuffer];\n  }\n  return [buffer, buffer, buffer, buffer];\n};\n\n/**\n * Calculates the absolute positioning (relative to document.body) to place a popover element\n *\n * @param anchor {HTMLElement} Element to anchor the popover to\n * @param popover {HTMLElement} Element containing the popover content\n * @param position {string} Position the user wants. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [forcePosition] {boolean} If true, use only the provided `position` value and don't try any other position\n * @param [align] {string} Cross-axis alignment. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [buffer=16] {number} Minimum distance between the popover and the bounding container\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [allowCrossAxis=true] {boolean} Whether to allow the popover to be positioned on the cross-axis\n * @param [container] {HTMLElement} Element the popover must be constrained to fit within\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If\n *  present, describes the size & constraints for an arrow element, and the\n *  function return value will include an `arrow` param with position details\n *\n * @returns {FindPopoverPositionResult} absolute page coordinates for the\n * popover, and the placement's relation to the anchor or undefined\n * there's no room.\n */\nexport function findPopoverPosition(_ref) {\n  var anchor = _ref.anchor,\n    popover = _ref.popover,\n    align = _ref.align,\n    position = _ref.position,\n    forcePosition = _ref.forcePosition,\n    _ref$buffer = _ref.buffer,\n    buffer = _ref$buffer === void 0 ? 16 : _ref$buffer,\n    _ref$offset = _ref.offset,\n    offset = _ref$offset === void 0 ? 0 : _ref$offset,\n    _ref$allowCrossAxis = _ref.allowCrossAxis,\n    allowCrossAxis = _ref$allowCrossAxis === void 0 ? true : _ref$allowCrossAxis,\n    container = _ref.container,\n    arrowConfig = _ref.arrowConfig,\n    returnBoundingBox = _ref.returnBoundingBox;\n  // find the screen-relative bounding boxes of the anchor, popover, and container\n  var anchorBoundingBox = getElementBoundingBox(anchor);\n  var popoverBoundingBox = getElementBoundingBox(popover);\n\n  // calculate the window's bounds\n  // window.(innerWidth|innerHeight) do not account for scrollbars\n  // so prefer the clientWidth/clientHeight of the DOM if available\n  var documentWidth = document.documentElement.clientWidth || window.innerWidth;\n  var documentHeight = document.documentElement.clientHeight || window.innerHeight;\n  var windowBoundingBox = {\n    top: 0,\n    right: documentWidth,\n    bottom: documentHeight,\n    left: 0,\n    height: documentHeight,\n    width: documentWidth\n  };\n\n  // if no container element is given fall back to using the window viewport\n  var containerBoundingBox = container ? getElementBoundingBox(container) : windowBoundingBox;\n\n  /**\n   * `position` was specified by the function caller and is a strong hint\n   * as to the preferred location of the popover relative to the anchor.\n   * However, we strongly prefer showing all of the popover content within\n   * the window+container boundary and will iterate over the four\n   * possible sides until a perfect fit is located. If none of the locations\n   * fully contain popover, the location with the best fit is selected.\n   *\n   * This approach first checks the preferred `position`, then its opposite\n   * along the same axis, next a location on the cross-axis, and finally it\n   * tests the remaining position.\n   *\n   * e.g.\n   * if position = \"top\" the order is top, bottom, left right\n   * if position = \"right\" the order is right, left, top, bottom\n   */\n\n  // Try the user-desired position first.\n  var iterationPositions = [position];\n  // keep user-defined alignment in the original positions.\n  var iterationAlignments = [align];\n  if (forcePosition !== true) {\n    iterationPositions.push(positionComplements[position]); // Try the complementary position.\n    iterationAlignments.push(align); // keep user-defined alignment in the complementary position.\n\n    if (allowCrossAxis) {\n      iterationPositions.push(positionSubstitutes[position],\n      // Switch to the cross axis.\n      positionComplements[positionSubstitutes[position]] // Try the complementary position on the cross axis.\n      );\n\n      iterationAlignments.push(undefined, undefined); // discard desired alignment on cross-axis\n    }\n  } else {\n    // position is forced, if it conflicts with the alignment then reset align to `null`\n    // e.g. original placement request for `downLeft` is moved to the `left` side, future calls\n    // will position and align `left`, and `leftLeft` is not a valid placement\n    if (position === align || align !== undefined && position === positionComplements[align]) {\n      iterationAlignments[0] = undefined;\n    }\n  }\n  var bestFit = undefined;\n  var bestPosition = null;\n  for (var idx = 0; idx < iterationPositions.length; idx++) {\n    var iterationPosition = iterationPositions[idx];\n\n    // See if we can find a position with a better fit than we've found so far.\n    var screenCoordinates = getPopoverScreenCoordinates({\n      position: iterationPosition,\n      align: iterationAlignments[idx],\n      anchorBoundingBox: anchorBoundingBox,\n      popoverBoundingBox: popoverBoundingBox,\n      windowBoundingBox: windowBoundingBox,\n      containerBoundingBox: containerBoundingBox,\n      offset: offset,\n      buffer: buffer,\n      arrowConfig: arrowConfig\n    });\n    if (bestFit === undefined || screenCoordinates.fit > bestFit) {\n      bestFit = screenCoordinates.fit;\n      bestPosition = {\n        fit: screenCoordinates.fit,\n        position: iterationPosition,\n        top: screenCoordinates.top + window.pageYOffset,\n        left: screenCoordinates.left + window.pageXOffset,\n        arrow: screenCoordinates.arrow\n      };\n\n      // If we've already found the ideal fit, use that position.\n      if (bestFit === 1) {\n        break;\n      }\n    }\n\n    // If we haven't improved the fit, then continue on and try a new position.\n  }\n\n  if (bestPosition == null) {\n    throw new Error('Failed to calculate bestPosition');\n  }\n  if (returnBoundingBox) {\n    bestPosition.anchorBoundingBox = anchorBoundingBox;\n  }\n  return bestPosition;\n}\n/**\n * Given a target position and the popover's surrounding context, returns either an\n * object with {top, left} screen coordinates or `null` if it's not possible to show\n * content in the target position\n * @param position {string} the target position, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param align {string} target alignment on the cross-axis, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param anchorBoundingBox {Object} bounding box of the anchor element\n * @param popoverBoundingBox {Object} bounding box of the popover element\n * @param windowBoundingBox {Object} bounding box of the window\n * @param containerBoundingBox {Object} bounding box of the container\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If present, describes the size &\n *  constraints for an arrow element, and the function return value will include an `arrow` param\n *  with position details\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [buffer=0] {number} Minimum distance between the popover's\n *  placement and the container edge\n *\n * @returns {GetPopoverScreenCoordinatesResult}\n *  object with top/left coordinates, the popover's relative position to the anchor, and how well the\n *  popover fits in the location (0.0 -> 1.0) coordinates and the popover's relative position, if\n *  there is no room in this placement then null\n */\nexport function getPopoverScreenCoordinates(_ref2) {\n  var _popoverPlacement, _ref3;\n  var position = _ref2.position,\n    align = _ref2.align,\n    anchorBoundingBox = _ref2.anchorBoundingBox,\n    popoverBoundingBox = _ref2.popoverBoundingBox,\n    windowBoundingBox = _ref2.windowBoundingBox,\n    containerBoundingBox = _ref2.containerBoundingBox,\n    arrowConfig = _ref2.arrowConfig,\n    _ref2$offset = _ref2.offset,\n    offset = _ref2$offset === void 0 ? 0 : _ref2$offset,\n    _ref2$buffer = _ref2.buffer,\n    buffer = _ref2$buffer === void 0 ? 0 : _ref2$buffer;\n  /**\n   * The goal is to find the best way to align the popover content\n   * on the given side of the anchor element. The popover prefers\n   * centering on the anchor but can shift along the cross-axis as needed.\n   *\n   * We return the top/left coordinates that best fit the popover inside\n   * the given boundaries, and also return the `fit` value which indicates\n   * what percentage of the popover is within the bounds.\n   *\n   * e.g. finding a location when position=top\n   * the preferred location is directly over the anchor\n   *\n   *        +----------------------+\n   *        |       popover        |\n   *        +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   * but if anchor doesn't have much (or any) room on its ride side\n   * the popover will shift to the left\n   *\n   *    +----------------------+\n   *    |       popover        |\n   *    +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   */\n\n  var crossAxisFirstSide = positionSubstitutes[position]; // \"top\" -> \"left\"\n  var crossAxisSecondSide = positionComplements[crossAxisFirstSide]; // \"left\" -> \"right\"\n  var crossAxisDimension = relatedDimension[crossAxisFirstSide]; // \"left\" -> \"width\"\n\n  var _getBufferValues = getBufferValues(buffer),\n    _getBufferValues2 = _slicedToArray(_getBufferValues, 4),\n    topBuffer = _getBufferValues2[0],\n    rightBuffer = _getBufferValues2[1],\n    bottomBuffer = _getBufferValues2[2],\n    leftBuffer = _getBufferValues2[3];\n  var _getCrossAxisPosition = getCrossAxisPosition({\n      crossAxisFirstSide: crossAxisFirstSide,\n      crossAxisSecondSide: crossAxisSecondSide,\n      crossAxisDimension: crossAxisDimension,\n      position: position,\n      align: align,\n      buffer: buffer,\n      offset: offset,\n      windowBoundingBox: windowBoundingBox,\n      containerBoundingBox: containerBoundingBox,\n      popoverBoundingBox: popoverBoundingBox,\n      anchorBoundingBox: anchorBoundingBox,\n      arrowConfig: arrowConfig\n    }),\n    crossAxisPosition = _getCrossAxisPosition.crossAxisPosition,\n    crossAxisArrowPosition = _getCrossAxisPosition.crossAxisArrowPosition;\n  var primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n  var primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  var _getPrimaryAxisPositi = getPrimaryAxisPosition({\n      position: position,\n      offset: offset,\n      popoverBoundingBox: popoverBoundingBox,\n      anchorBoundingBox: anchorBoundingBox,\n      arrowConfig: arrowConfig\n    }),\n    primaryAxisPosition = _getPrimaryAxisPositi.primaryAxisPosition,\n    primaryAxisArrowPosition = _getPrimaryAxisPositi.primaryAxisArrowPosition;\n  var popoverPlacement = (_popoverPlacement = {}, _defineProperty(_popoverPlacement, crossAxisFirstSide, crossAxisPosition), _defineProperty(_popoverPlacement, primaryAxisPositionName, primaryAxisPosition), _popoverPlacement);\n\n  // calculate the fit of the popover in this location\n  // fit is in range 0.0 -> 1.0 and is the percentage of the popover which is visible in this location\n  var combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox);\n\n  // shrink the visible bounding box by `buffer`\n  // to compute a fit value\n  combinedBoundingBox.top += topBuffer;\n  combinedBoundingBox.right -= rightBuffer;\n  combinedBoundingBox.bottom -= bottomBuffer;\n  combinedBoundingBox.left += leftBuffer;\n  var fit = getVisibleFit({\n    top: popoverPlacement.top,\n    right: popoverPlacement.left + popoverBoundingBox.width,\n    bottom: popoverPlacement.top + popoverBoundingBox.height,\n    left: popoverPlacement.left,\n    width: popoverBoundingBox.width,\n    height: popoverBoundingBox.height\n  }, combinedBoundingBox);\n  var arrow = arrowConfig ? (_ref3 = {}, _defineProperty(_ref3, crossAxisFirstSide, crossAxisArrowPosition - popoverPlacement[crossAxisFirstSide]), _defineProperty(_ref3, primaryAxisPositionName, primaryAxisArrowPosition), _ref3) : undefined;\n  return {\n    fit: fit,\n    top: popoverPlacement.top,\n    left: popoverPlacement.left,\n    arrow: arrow ? {\n      left: arrow.left,\n      top: arrow.top\n    } : undefined\n  };\n}\nfunction getCrossAxisPosition(_ref4) {\n  var crossAxisFirstSide = _ref4.crossAxisFirstSide,\n    crossAxisSecondSide = _ref4.crossAxisSecondSide,\n    crossAxisDimension = _ref4.crossAxisDimension,\n    position = _ref4.position,\n    align = _ref4.align,\n    buffer = _ref4.buffer,\n    offset = _ref4.offset,\n    windowBoundingBox = _ref4.windowBoundingBox,\n    containerBoundingBox = _ref4.containerBoundingBox,\n    popoverBoundingBox = _ref4.popoverBoundingBox,\n    anchorBoundingBox = _ref4.anchorBoundingBox,\n    arrowConfig = _ref4.arrowConfig;\n  // how much of the popover overflows past either side of the anchor if its centered\n  var popoverSizeOnCrossAxis = popoverBoundingBox[crossAxisDimension];\n  var anchorSizeOnCrossAxis = anchorBoundingBox[crossAxisDimension];\n  var anchorHalfSize = anchorSizeOnCrossAxis / 2;\n\n  // the popover's original position on the cross-axis is determined by:\n  var crossAxisPositionOriginal = anchorBoundingBox[crossAxisFirstSide] +\n  // where the anchor is located\n  anchorHalfSize -\n  // plus half anchor dimension\n  popoverSizeOnCrossAxis / 2; // less half the popover dimension\n\n  // To fit the content within both the window and container,\n  // compute the smaller of the two spaces along each edge\n  var combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox);\n  var availableSpace = getAvailableSpace(anchorBoundingBox, combinedBoundingBox, buffer, offset, position);\n  var minimumSpace = arrowConfig ? arrowConfig.arrowBuffer : 0;\n  var contentOverflowSize = (popoverSizeOnCrossAxis - anchorSizeOnCrossAxis) / 2;\n  var alignAmount = 0;\n  var alignDirection = 1;\n  var amountOfShiftNeeded = 0;\n  var shiftDirection = 1;\n  if (align != null) {\n    // no alignment, find how much the container boundary requires the content to shift\n    alignDirection = align === 'top' || align === 'left' ? 1 : -1;\n    alignAmount = contentOverflowSize;\n    var alignedOverflowAmount = contentOverflowSize + alignAmount;\n    var needsShift = alignedOverflowAmount > availableSpace[positionComplements[align]];\n    amountOfShiftNeeded = needsShift ? alignedOverflowAmount - availableSpace[positionComplements[align]] : 0;\n    shiftDirection = -1 * alignDirection;\n  } else {\n    // shifting the popover to one side may yield a better fit\n    var spaceAvailableOnFirstSide = availableSpace[crossAxisFirstSide];\n    var spaceAvailableOnSecondSide = availableSpace[crossAxisSecondSide];\n    var isShiftTowardFirstSide = spaceAvailableOnFirstSide > spaceAvailableOnSecondSide;\n    shiftDirection = isShiftTowardFirstSide ? -1 : 1;\n\n    // determine which direction has more room and the popover should shift to\n    var leastAvailableSpace = Math.min(spaceAvailableOnFirstSide, spaceAvailableOnSecondSide);\n    var _needsShift = contentOverflowSize > leastAvailableSpace;\n    amountOfShiftNeeded = _needsShift ? contentOverflowSize - leastAvailableSpace : 0;\n  }\n\n  // shift over the popover if necessary\n  var shiftAmount = amountOfShiftNeeded * shiftDirection;\n  var crossAxisPosition = crossAxisPositionOriginal + shiftAmount + alignAmount * alignDirection;\n\n  // if an `arrowConfig` is specified, find where to position the arrow\n  var crossAxisArrowPosition;\n  if (arrowConfig) {\n    var arrowWidth = arrowConfig.arrowWidth;\n    crossAxisArrowPosition = anchorBoundingBox[crossAxisFirstSide] + anchorHalfSize - arrowWidth / 2;\n\n    // make sure there's enough buffer around the arrow\n    // by calculating how how much the arrow would need to move\n    // but instead of moving the arrow, shift the popover content\n    if (crossAxisArrowPosition < crossAxisPosition + minimumSpace) {\n      // arrow is too close to the minimum side\n      var difference = crossAxisPosition + minimumSpace - crossAxisArrowPosition;\n      crossAxisPosition -= difference;\n    } else if (crossAxisArrowPosition + minimumSpace + arrowWidth > crossAxisPosition + popoverSizeOnCrossAxis) {\n      // arrow is too close to the maximum side\n      var edge = crossAxisPosition + popoverSizeOnCrossAxis;\n      var _difference = crossAxisArrowPosition - (edge - minimumSpace - arrowWidth);\n      crossAxisPosition += _difference;\n    }\n  }\n  return {\n    crossAxisPosition: crossAxisPosition,\n    crossAxisArrowPosition: crossAxisArrowPosition\n  };\n}\nfunction getPrimaryAxisPosition(_ref5) {\n  var position = _ref5.position,\n    offset = _ref5.offset,\n    popoverBoundingBox = _ref5.popoverBoundingBox,\n    anchorBoundingBox = _ref5.anchorBoundingBox,\n    arrowConfig = _ref5.arrowConfig;\n  // if positioning to the top or left, the target position decreases\n  // from the anchor's top or left, otherwise the position adds to the anchor's\n  var isOffsetDecreasing = position === 'top' || position === 'left';\n  var primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n  var popoverSizeOnPrimaryAxis = popoverBoundingBox[primaryAxisDimension];\n\n  // start at the top or left edge of the anchor element\n  var primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n  var anchorEdgeOrigin = anchorBoundingBox[primaryAxisPositionName];\n\n  // find the popover position on the primary axis\n  var anchorSizeOnPrimaryAxis = anchorBoundingBox[primaryAxisDimension];\n  var primaryAxisOffset = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : anchorSizeOnPrimaryAxis;\n  var contentOffset = (offset + primaryAxisOffset) * (isOffsetDecreasing ? -1 : 1);\n  var primaryAxisPosition = anchorEdgeOrigin + contentOffset;\n  var primaryAxisArrowPosition;\n  if (arrowConfig) {\n    primaryAxisArrowPosition = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : 0;\n  }\n  return {\n    primaryAxisPosition: primaryAxisPosition,\n    primaryAxisArrowPosition: primaryAxisArrowPosition\n  };\n}\n\n/**\n * Finds the client pixel coordinate of each edge for the element's bounding box,\n * and the bounding box's width & height\n *\n * @param {HTMLElement} element\n * @returns {{top: number, right: number, bottom: number, left: number, height: number, width: number}}\n */\nexport function getElementBoundingBox(element) {\n  var rect = element.getBoundingClientRect();\n  return {\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    height: rect.height,\n    width: rect.width\n  };\n}\n\n/**\n * Calculates the available content space between anchor and container\n *\n * @param {Object} anchorBoundingBox Client bounding box of the anchor element\n * @param {Object} containerBoundingBox Client bounding box of the container element\n * @param {number} buffer Minimum distance between the popover and the bounding container\n * @param {number} offset Distance between the popover and the anchor\n * @param {string} offsetSide Side the offset needs to be applied to, one\n *  of [\"top\", \"right\", \"bottom\", \"left\"]\n * @returns {{top: number, right: number, bottom: number, left: number}}\n */\nexport function getAvailableSpace(anchorBoundingBox, containerBoundingBox, buffer, offset, offsetSide) {\n  var _getBufferValues3 = getBufferValues(buffer),\n    _getBufferValues4 = _slicedToArray(_getBufferValues3, 4),\n    topBuffer = _getBufferValues4[0],\n    rightBuffer = _getBufferValues4[1],\n    bottomBuffer = _getBufferValues4[2],\n    leftBuffer = _getBufferValues4[3];\n  return {\n    top: anchorBoundingBox.top - containerBoundingBox.top - topBuffer - (offsetSide === 'top' ? offset : 0),\n    right: containerBoundingBox.right - anchorBoundingBox.right - rightBuffer - (offsetSide === 'right' ? offset : 0),\n    bottom: containerBoundingBox.bottom - anchorBoundingBox.bottom - bottomBuffer - (offsetSide === 'bottom' ? offset : 0),\n    left: anchorBoundingBox.left - containerBoundingBox.left - leftBuffer - (offsetSide === 'left' ? offset : 0)\n  };\n}\n\n/**\n * Computes the fit (overlap) of the content within the container, fit is in range 0.0 => 1.0\n * @param contentBoundingBox bounding box of content to calculate fit for\n * @param containerBoundingBox bounding box of container\n * @returns {number}\n */\nexport function getVisibleFit(contentBoundingBox, containerBoundingBox) {\n  var intersection = intersectBoundingBoxes(contentBoundingBox, containerBoundingBox);\n  if (intersection.left > intersection.right || intersection.top > intersection.top) {\n    // there is no intersection, the boxes are completely separated on at least one axis\n    return 0;\n  }\n  var intersectionArea = (intersection.right - intersection.left) * (intersection.bottom - intersection.top);\n  var contentArea = (contentBoundingBox.right - contentBoundingBox.left) * (contentBoundingBox.bottom - contentBoundingBox.top);\n  return intersectionArea / contentArea;\n}\n\n/**\n * Calculates the intersection space between two bounding boxes\n *\n * @param firstBox\n * @param secondBox\n * @returns {EuiClientRect}\n */\nexport function intersectBoundingBoxes(firstBox, secondBox) {\n  var top = Math.max(firstBox.top, secondBox.top);\n  var right = Math.min(firstBox.right, secondBox.right);\n  var bottom = Math.min(firstBox.bottom, secondBox.bottom);\n  var left = Math.max(firstBox.left, secondBox.left);\n  var height = Math.max(bottom - top, 0);\n  var width = Math.max(right - left, 0);\n  return {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left,\n    height: height,\n    width: width\n  };\n}\n\n/**\n * Returns the top-most defined z-index in the element's ancestor hierarchy\n * relative to the `target` element; if no z-index is defined, returns 0\n * @param element {HTMLElement}\n * @param cousin {HTMLElement}\n * @returns {number}\n */\nexport function getElementZIndex(element, cousin) {\n  /**\n   * finding the z-index of `element` is not the full story\n   * its the CSS stacking context that is important\n   * take this DOM for example:\n   * body\n   *   section[z-index: 1000]\n   *     p[z-index: 500]\n   *       button\n   *   div\n   *\n   * what z-index does the `div` need to display next to `button`?\n   * the `div` and `section` are where the stacking context splits\n   * so `div` needs to copy `section`'s z-index in order to\n   * appear next to / over `button`\n   *\n   * calculate this by starting at `button` and finding its offsetParents\n   * then walk the parents from top -> down until the stacking context\n   * split is found, or if there is no split then a specific z-index is unimportant\n   */\n\n  // build the array of the element + its offset parents\n  var nodesToInspect = [];\n  while (true) {\n    nodesToInspect.push(element);\n\n    // AFAICT this is a valid cast - the libdefs appear wrong\n    element = element.offsetParent;\n\n    // stop if there is no parent\n    if (element == null) {\n      break;\n    }\n\n    // stop if the parent contains the related element\n    // as this is the z-index ancestor\n    if (element.contains(cousin)) {\n      break;\n    }\n  }\n\n  // reverse the nodes to walk from top -> element\n  nodesToInspect.reverse();\n  for (var _i2 = 0, _nodesToInspect = nodesToInspect; _i2 < _nodesToInspect.length; _i2++) {\n    var node = _nodesToInspect[_i2];\n    // get this node's z-index css value\n    var zIndex = window.document.defaultView.getComputedStyle(node).getPropertyValue('z-index');\n\n    // if the z-index is not a number (e.g. \"auto\") return null, else the value\n    var parsedZIndex = parseInt(zIndex, 10);\n    if (!isNaN(parsedZIndex)) {\n      return parsedZIndex;\n    }\n  }\n  return 0;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
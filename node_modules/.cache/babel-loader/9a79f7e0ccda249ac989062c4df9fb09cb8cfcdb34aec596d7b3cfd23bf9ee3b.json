{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport { cloneElement } from 'react';\nimport { isBoolean, isString, isNumber, isUndefined } from '../../services/predicate';\nimport { isElement } from 'react-is';\nfunction isPrimitive(value) {\n  return isBoolean(value) || isString(value) || isNumber(value) || isUndefined(value);\n}\nfunction hasPropName(child) {\n  return child ? _typeof(child) === 'object' && child.hasOwnProperty('propName') : false;\n}\n\n/**\n * Replaces placeholder values in `input` with their matching value in `values`\n * e.g. input:'Hello, {name}' will replace `{name}` with `values[name]`\n * @param {string} input\n * @param {RenderableValues} values\n * @param {Function} i18nMappingFunc\n * @returns {string | React.ReactChild[]}\n */\nexport function processStringToChildren(input, values, i18nMappingFunc) {\n  var children = [];\n  var child;\n  function appendCharToChild(char) {\n    if (child === undefined) {\n      // starting a new string literal\n      child = char;\n    } else if (typeof child === 'string') {\n      // existing string literal\n      child = child + char;\n    } else if (hasPropName(child)) {\n      // adding to the propName of a values lookup\n      child.propName = child.propName + char;\n    }\n  }\n  function appendValueToChildren(value) {\n    if (value === undefined) {\n      return;\n    } else if (isElement(value)) {\n      // an array with any ReactElements will be kept as an array\n      // so they need to be assigned a key\n      children.push( /*#__PURE__*/cloneElement(value, {\n        key: children.length\n      }));\n    } else if (hasPropName(value)) {\n      // this won't be called, propName children are converted to a ReactChild before calling this\n    } else {\n      // everything else can go straight in\n      if (i18nMappingFunc !== undefined && typeof value === 'string') {\n        value = i18nMappingFunc(value);\n      }\n      children.push(value);\n    }\n  }\n\n  // if we don't encounter a non-primitive\n  // then `children` can be concatenated together at the end\n  var encounteredNonPrimitive = false;\n  for (var i = 0; i < input.length; i++) {\n    var char = input[i];\n    if (char === '\\\\') {\n      // peek at the next character to know if this is an escape\n      var nextChar = input[i + 1];\n      var charToAdd = char; // if this isn't an escape sequence then we will add the backslash\n\n      if (nextChar === '{' || nextChar === '}') {\n        // escaping a brace\n        i += 1; // advance passed the brace\n        charToAdd = input[i];\n      }\n      appendCharToChild(charToAdd);\n    } else if (char === '{') {\n      appendValueToChildren(child);\n      child = {\n        propName: ''\n      };\n    } else if (char === '}') {\n      var propName = child.propName;\n      if (!values.hasOwnProperty(propName)) {\n        throw new Error(\"Key \\\"\".concat(propName, \"\\\" not found in \").concat(JSON.stringify(values, null, 2)));\n      }\n      var propValue = values[propName];\n      encounteredNonPrimitive = encounteredNonPrimitive || !isPrimitive(propValue);\n      appendValueToChildren(propValue);\n      child = undefined;\n    } else {\n      appendCharToChild(char);\n    }\n  }\n\n  // include any remaining child value\n  appendValueToChildren(child);\n  return encounteredNonPrimitive ? children : children.join('');\n}","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","cloneElement","isBoolean","isString","isNumber","isUndefined","isElement","isPrimitive","value","hasPropName","child","hasOwnProperty","processStringToChildren","input","values","i18nMappingFunc","children","appendCharToChild","char","undefined","propName","appendValueToChildren","push","key","length","encounteredNonPrimitive","i","nextChar","charToAdd","Error","concat","JSON","stringify","propValue","join"],"sources":["/home/runner/work/broadway-lite/broadway-lite/node_modules/@elastic/eui/es/components/i18n/i18n_util.js"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport { cloneElement } from 'react';\nimport { isBoolean, isString, isNumber, isUndefined } from '../../services/predicate';\nimport { isElement } from 'react-is';\nfunction isPrimitive(value) {\n  return isBoolean(value) || isString(value) || isNumber(value) || isUndefined(value);\n}\nfunction hasPropName(child) {\n  return child ? _typeof(child) === 'object' && child.hasOwnProperty('propName') : false;\n}\n\n/**\n * Replaces placeholder values in `input` with their matching value in `values`\n * e.g. input:'Hello, {name}' will replace `{name}` with `values[name]`\n * @param {string} input\n * @param {RenderableValues} values\n * @param {Function} i18nMappingFunc\n * @returns {string | React.ReactChild[]}\n */\nexport function processStringToChildren(input, values, i18nMappingFunc) {\n  var children = [];\n  var child;\n  function appendCharToChild(char) {\n    if (child === undefined) {\n      // starting a new string literal\n      child = char;\n    } else if (typeof child === 'string') {\n      // existing string literal\n      child = child + char;\n    } else if (hasPropName(child)) {\n      // adding to the propName of a values lookup\n      child.propName = child.propName + char;\n    }\n  }\n  function appendValueToChildren(value) {\n    if (value === undefined) {\n      return;\n    } else if (isElement(value)) {\n      // an array with any ReactElements will be kept as an array\n      // so they need to be assigned a key\n      children.push( /*#__PURE__*/cloneElement(value, {\n        key: children.length\n      }));\n    } else if (hasPropName(value)) {\n      // this won't be called, propName children are converted to a ReactChild before calling this\n    } else {\n      // everything else can go straight in\n      if (i18nMappingFunc !== undefined && typeof value === 'string') {\n        value = i18nMappingFunc(value);\n      }\n      children.push(value);\n    }\n  }\n\n  // if we don't encounter a non-primitive\n  // then `children` can be concatenated together at the end\n  var encounteredNonPrimitive = false;\n  for (var i = 0; i < input.length; i++) {\n    var char = input[i];\n    if (char === '\\\\') {\n      // peek at the next character to know if this is an escape\n      var nextChar = input[i + 1];\n      var charToAdd = char; // if this isn't an escape sequence then we will add the backslash\n\n      if (nextChar === '{' || nextChar === '}') {\n        // escaping a brace\n        i += 1; // advance passed the brace\n        charToAdd = input[i];\n      }\n      appendCharToChild(charToAdd);\n    } else if (char === '{') {\n      appendValueToChildren(child);\n      child = {\n        propName: ''\n      };\n    } else if (char === '}') {\n      var propName = child.propName;\n      if (!values.hasOwnProperty(propName)) {\n        throw new Error(\"Key \\\"\".concat(propName, \"\\\" not found in \").concat(JSON.stringify(values, null, 2)));\n      }\n      var propValue = values[propName];\n      encounteredNonPrimitive = encounteredNonPrimitive || !isPrimitive(propValue);\n      appendValueToChildren(propValue);\n      child = undefined;\n    } else {\n      appendCharToChild(char);\n    }\n  }\n\n  // include any remaining child value\n  appendValueToChildren(child);\n  return encounteredNonPrimitive ? children : children.join('');\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
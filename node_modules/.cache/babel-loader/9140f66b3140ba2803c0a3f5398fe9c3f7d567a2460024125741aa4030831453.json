{"ast":null,"code":"/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nvar getSearchableLabel = function getSearchableLabel(option) {\n  var normalize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var searchableLabel = option.searchableLabel || option.label;\n  return normalize ? searchableLabel.trim().toLowerCase() : searchableLabel;\n};\nvar getSelectedOptionForSearchValue = function getSelectedOptionForSearchValue(searchValue, selectedOptions) {\n  var normalizedSearchValue = searchValue.toLowerCase();\n  return selectedOptions.find(function (option) {\n    return getSearchableLabel(option) === normalizedSearchValue;\n  });\n};\nvar collectMatchingOption = function collectMatchingOption(accumulator, option, normalizedSearchValue, isPreFiltered, selectedOptions) {\n  // Don't show options that have already been requested if\n  // the selectedOptions list exists\n  if (selectedOptions) {\n    var selectedOption = getSelectedOptionForSearchValue(getSearchableLabel(option, false), selectedOptions);\n    if (selectedOption) {\n      return false;\n    }\n  }\n\n  // If the options have already been prefiltered then we can skip filtering against the search value.\n  // TODO: I still don't quite understand how this works when hooked up to async\n  if (isPreFiltered) {\n    accumulator.push(option);\n    return;\n  }\n  if (!normalizedSearchValue) {\n    accumulator.push(option);\n    return;\n  }\n  var normalizedOption = getSearchableLabel(option);\n  if (normalizedOption.includes(normalizedSearchValue)) {\n    accumulator.push(option);\n  }\n};\nexport var getMatchingOptions = function getMatchingOptions(options, searchValue, isPreFiltered, selectedOptions) {\n  var normalizedSearchValue = searchValue.toLowerCase();\n  var matchingOptions = [];\n  options.forEach(function (option) {\n    collectMatchingOption(matchingOptions, option, normalizedSearchValue, isPreFiltered, selectedOptions);\n  });\n  return matchingOptions;\n};","map":{"version":3,"names":["getSearchableLabel","option","normalize","arguments","length","undefined","searchableLabel","label","trim","toLowerCase","getSelectedOptionForSearchValue","searchValue","selectedOptions","normalizedSearchValue","find","collectMatchingOption","accumulator","isPreFiltered","selectedOption","push","normalizedOption","includes","getMatchingOptions","options","matchingOptions","forEach"],"sources":["/home/runner/work/broadway-lite/broadway-lite/node_modules/@elastic/eui/es/components/selectable/matching_options.js"],"sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nvar getSearchableLabel = function getSearchableLabel(option) {\n  var normalize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var searchableLabel = option.searchableLabel || option.label;\n  return normalize ? searchableLabel.trim().toLowerCase() : searchableLabel;\n};\nvar getSelectedOptionForSearchValue = function getSelectedOptionForSearchValue(searchValue, selectedOptions) {\n  var normalizedSearchValue = searchValue.toLowerCase();\n  return selectedOptions.find(function (option) {\n    return getSearchableLabel(option) === normalizedSearchValue;\n  });\n};\nvar collectMatchingOption = function collectMatchingOption(accumulator, option, normalizedSearchValue, isPreFiltered, selectedOptions) {\n  // Don't show options that have already been requested if\n  // the selectedOptions list exists\n  if (selectedOptions) {\n    var selectedOption = getSelectedOptionForSearchValue(getSearchableLabel(option, false), selectedOptions);\n    if (selectedOption) {\n      return false;\n    }\n  }\n\n  // If the options have already been prefiltered then we can skip filtering against the search value.\n  // TODO: I still don't quite understand how this works when hooked up to async\n  if (isPreFiltered) {\n    accumulator.push(option);\n    return;\n  }\n  if (!normalizedSearchValue) {\n    accumulator.push(option);\n    return;\n  }\n  var normalizedOption = getSearchableLabel(option);\n  if (normalizedOption.includes(normalizedSearchValue)) {\n    accumulator.push(option);\n  }\n};\nexport var getMatchingOptions = function getMatchingOptions(options, searchValue, isPreFiltered, selectedOptions) {\n  var normalizedSearchValue = searchValue.toLowerCase();\n  var matchingOptions = [];\n  options.forEach(function (option) {\n    collectMatchingOption(matchingOptions, option, normalizedSearchValue, isPreFiltered, selectedOptions);\n  });\n  return matchingOptions;\n};"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,kBAAkB,GAAG,SAASA,kBAAkBA,CAACC,MAAM,EAAE;EAC3D,IAAIC,SAAS,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI;EACxF,IAAIG,eAAe,GAAGL,MAAM,CAACK,eAAe,IAAIL,MAAM,CAACM,KAAK;EAC5D,OAAOL,SAAS,GAAGI,eAAe,CAACE,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,GAAGH,eAAe;AAC3E,CAAC;AACD,IAAII,+BAA+B,GAAG,SAASA,+BAA+BA,CAACC,WAAW,EAAEC,eAAe,EAAE;EAC3G,IAAIC,qBAAqB,GAAGF,WAAW,CAACF,WAAW,CAAC,CAAC;EACrD,OAAOG,eAAe,CAACE,IAAI,CAAC,UAAUb,MAAM,EAAE;IAC5C,OAAOD,kBAAkB,CAACC,MAAM,CAAC,KAAKY,qBAAqB;EAC7D,CAAC,CAAC;AACJ,CAAC;AACD,IAAIE,qBAAqB,GAAG,SAASA,qBAAqBA,CAACC,WAAW,EAAEf,MAAM,EAAEY,qBAAqB,EAAEI,aAAa,EAAEL,eAAe,EAAE;EACrI;EACA;EACA,IAAIA,eAAe,EAAE;IACnB,IAAIM,cAAc,GAAGR,+BAA+B,CAACV,kBAAkB,CAACC,MAAM,EAAE,KAAK,CAAC,EAAEW,eAAe,CAAC;IACxG,IAAIM,cAAc,EAAE;MAClB,OAAO,KAAK;IACd;EACF;;EAEA;EACA;EACA,IAAID,aAAa,EAAE;IACjBD,WAAW,CAACG,IAAI,CAAClB,MAAM,CAAC;IACxB;EACF;EACA,IAAI,CAACY,qBAAqB,EAAE;IAC1BG,WAAW,CAACG,IAAI,CAAClB,MAAM,CAAC;IACxB;EACF;EACA,IAAImB,gBAAgB,GAAGpB,kBAAkB,CAACC,MAAM,CAAC;EACjD,IAAImB,gBAAgB,CAACC,QAAQ,CAACR,qBAAqB,CAAC,EAAE;IACpDG,WAAW,CAACG,IAAI,CAAClB,MAAM,CAAC;EAC1B;AACF,CAAC;AACD,OAAO,IAAIqB,kBAAkB,GAAG,SAASA,kBAAkBA,CAACC,OAAO,EAAEZ,WAAW,EAAEM,aAAa,EAAEL,eAAe,EAAE;EAChH,IAAIC,qBAAqB,GAAGF,WAAW,CAACF,WAAW,CAAC,CAAC;EACrD,IAAIe,eAAe,GAAG,EAAE;EACxBD,OAAO,CAACE,OAAO,CAAC,UAAUxB,MAAM,EAAE;IAChCc,qBAAqB,CAACS,eAAe,EAAEvB,MAAM,EAAEY,qBAAqB,EAAEI,aAAa,EAAEL,eAAe,CAAC;EACvG,CAAC,CAAC;EACF,OAAOY,eAAe;AACxB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nexport var assertNever = function assertNever(x) {\n  throw new Error(\"Unexpected value \".concat(x));\n};\n\n// utility types:\n/**\n * XOR for some properties applied to a type\n * (XOR is one of these but not both or neither)\n *\n * Usage: OneOf<typeToExtend, one | but | not | multiple | of | these | are | required>\n *\n * To require aria-label or aria-labelledby but not both\n * Example: OneOf<Type, 'aria-label' | 'aria-labelledby'>\n */\n/**\n * Wraps Object.keys with proper typescript definition of the resulting array\n */\nexport function keysOf(obj) {\n  return Object.keys(obj);\n}\n\n/**\n * Like `keyof typeof`, but for getting values instead of keys\n * ValueOf<typeof {key1: 'value1', key2: 'value2'}>\n * Results in `'value1' | 'value2'`\n */\n\n// Returns the props of a given HTML element\n\n// Utility methods for ApplyClassComponentDefaults\n\n/**\n * Because of how TypeScript's LibraryManagedAttributes is designed to handle defaultProps (https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#support-for-defaultprops-in-jsx)\n * we can't directly export the props definition as the defaulted values are not made optional,\n * because it isn't processed by LibraryManagedAttributes. To get around this, we:\n * - remove the props which have default values applied\n * - export (Props - Defaults) & Partial<Defaults>\n */\n\n// definition of Props, made optional, that are have keys in defaultProps\n/*\nhttps://github.com/Microsoft/TypeScript/issues/28339\nProblem: Pick and Omit do not distribute over union types, which manifests when\noptional values become required after a Pick or Omit operation. These\nDistributive forms correctly operate on union types, preserving optionality.\n */\n/*\nTypeScript's discriminated unions are overly permissive: as long as one type of the union is satisfied\nthe other types are not validated against. For example:\n\ntype Foo = {\n  value: string,\n  foo: string\n};\ntype Bar = {\n  value: number,\n  bar: string\n}\nfunction what(x: Foo | Bar) {\n  return x.value;\n}\n\nAs you would expect -\n\nwhat({ value: 'asdf', foo: 'asdf' }); // fine\nwhat({ value: 5, foo: 'asdf' }); // error\nwhat({ value: 5, bar: 'asdf' }); // fine\nwhat({ value: 'asdf', bar: 'asdf' }); // error\n\nHowever, if Foo is satisfied then you can pass any value you want to Bar's unique properties:\nwhat({ value: 'asdf', foo: 'asdf', bar: false }) // works\n\nTypeScript is okay with this as a type guard would detect the object is Foo and prevent accessing `bar`.\nUnfortunately this prevents feedback to the user about potentially unintentional effects, for example:\n\nA common pattern in EUI is to render something as a div OR as a button, depending on if an onClick prop is passed.\npassing additional props down through `...rest`, which can be specified as\n\ntype Spanlike = HTMLAttributes<HTMLSpanElement>;\ntype Buttonlike = { onClick: MouseEventHandler<HTMLButtonElement> }; // onClick is the discriminant\nReact.FunctionComponent<Spanlike | Buttonlike>\n\nInternally, the component would have a type guard to check if props contains `onClick` and resolve to Buttonlike.\nExternally, however, you could use the component as\n\n<Component value=\"buzz\"/>\n\nand no error would occur as the Spanlike type is satisfied and the type guard would prevent accessing button attributes.\nThis prevents immediate feedback to the develop, and would actually lead to React warnings as the `value` prop would\nstill propagate down to the span's props, which is invalid. The following two utility types provide a solution for\ncreating exclusive unions:\n\nReact.FunctionComponent<ExclusiveUnion<Spanlike, Buttonlike>>\n */\n/**\n * Returns member keys in U not present in T set to never\n * T = { 'one', 'two', 'three' }\n * U = { 'three', 'four', 'five' }\n * returns { 'four': never, 'five': never }\n */\n/**\n * Allow either T or U, preventing any additional keys of the other type from being present\n */\n/**\n * For components that conditionally render <button> or <a>\n * Convenience types for extending base props (T) and\n * element-specific props (P) with standard clickable properties\n *\n * These will likely be used together, along with `ExclusiveUnion`:\n *\n * type AnchorLike = PropsForAnchor<BaseProps>\n * type ButtonLike = PropsForButton<BaseProps>\n * type ComponentProps = ExclusiveUnion<AnchorLike, ButtonLike>\n * const Component: FunctionComponent<ComponentProps> ...\n */\n/**\n * Replaces all properties on any type as optional, includes nested types\n *\n * @example\n * ```ts\n * interface Person {\n *  name: string;\n *  age?: number;\n *  spouse: Person;\n *  children: Person[];\n * }\n * type PartialPerson = RecursivePartial<Person>;\n * // results in\n * interface PartialPerson {\n *  name?: string;\n *  age?: number;\n *  spouse?: RecursivePartial<Person>;\n *  children?: RecursivePartial<Person>[]\n * }\n * ```\n */","map":{"version":3,"names":["assertNever","x","Error","concat","keysOf","obj","Object","keys"],"sources":["/home/runner/work/broadway-lite/broadway-lite/node_modules/@elastic/eui/es/components/common.js"],"sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nexport var assertNever = function assertNever(x) {\n  throw new Error(\"Unexpected value \".concat(x));\n};\n\n// utility types:\n/**\n * XOR for some properties applied to a type\n * (XOR is one of these but not both or neither)\n *\n * Usage: OneOf<typeToExtend, one | but | not | multiple | of | these | are | required>\n *\n * To require aria-label or aria-labelledby but not both\n * Example: OneOf<Type, 'aria-label' | 'aria-labelledby'>\n */\n/**\n * Wraps Object.keys with proper typescript definition of the resulting array\n */\nexport function keysOf(obj) {\n  return Object.keys(obj);\n}\n\n/**\n * Like `keyof typeof`, but for getting values instead of keys\n * ValueOf<typeof {key1: 'value1', key2: 'value2'}>\n * Results in `'value1' | 'value2'`\n */\n\n// Returns the props of a given HTML element\n\n// Utility methods for ApplyClassComponentDefaults\n\n/**\n * Because of how TypeScript's LibraryManagedAttributes is designed to handle defaultProps (https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#support-for-defaultprops-in-jsx)\n * we can't directly export the props definition as the defaulted values are not made optional,\n * because it isn't processed by LibraryManagedAttributes. To get around this, we:\n * - remove the props which have default values applied\n * - export (Props - Defaults) & Partial<Defaults>\n */\n\n// definition of Props, made optional, that are have keys in defaultProps\n/*\nhttps://github.com/Microsoft/TypeScript/issues/28339\nProblem: Pick and Omit do not distribute over union types, which manifests when\noptional values become required after a Pick or Omit operation. These\nDistributive forms correctly operate on union types, preserving optionality.\n */\n/*\nTypeScript's discriminated unions are overly permissive: as long as one type of the union is satisfied\nthe other types are not validated against. For example:\n\ntype Foo = {\n  value: string,\n  foo: string\n};\ntype Bar = {\n  value: number,\n  bar: string\n}\nfunction what(x: Foo | Bar) {\n  return x.value;\n}\n\nAs you would expect -\n\nwhat({ value: 'asdf', foo: 'asdf' }); // fine\nwhat({ value: 5, foo: 'asdf' }); // error\nwhat({ value: 5, bar: 'asdf' }); // fine\nwhat({ value: 'asdf', bar: 'asdf' }); // error\n\nHowever, if Foo is satisfied then you can pass any value you want to Bar's unique properties:\nwhat({ value: 'asdf', foo: 'asdf', bar: false }) // works\n\nTypeScript is okay with this as a type guard would detect the object is Foo and prevent accessing `bar`.\nUnfortunately this prevents feedback to the user about potentially unintentional effects, for example:\n\nA common pattern in EUI is to render something as a div OR as a button, depending on if an onClick prop is passed.\npassing additional props down through `...rest`, which can be specified as\n\ntype Spanlike = HTMLAttributes<HTMLSpanElement>;\ntype Buttonlike = { onClick: MouseEventHandler<HTMLButtonElement> }; // onClick is the discriminant\nReact.FunctionComponent<Spanlike | Buttonlike>\n\nInternally, the component would have a type guard to check if props contains `onClick` and resolve to Buttonlike.\nExternally, however, you could use the component as\n\n<Component value=\"buzz\"/>\n\nand no error would occur as the Spanlike type is satisfied and the type guard would prevent accessing button attributes.\nThis prevents immediate feedback to the develop, and would actually lead to React warnings as the `value` prop would\nstill propagate down to the span's props, which is invalid. The following two utility types provide a solution for\ncreating exclusive unions:\n\nReact.FunctionComponent<ExclusiveUnion<Spanlike, Buttonlike>>\n */\n/**\n * Returns member keys in U not present in T set to never\n * T = { 'one', 'two', 'three' }\n * U = { 'three', 'four', 'five' }\n * returns { 'four': never, 'five': never }\n */\n/**\n * Allow either T or U, preventing any additional keys of the other type from being present\n */\n/**\n * For components that conditionally render <button> or <a>\n * Convenience types for extending base props (T) and\n * element-specific props (P) with standard clickable properties\n *\n * These will likely be used together, along with `ExclusiveUnion`:\n *\n * type AnchorLike = PropsForAnchor<BaseProps>\n * type ButtonLike = PropsForButton<BaseProps>\n * type ComponentProps = ExclusiveUnion<AnchorLike, ButtonLike>\n * const Component: FunctionComponent<ComponentProps> ...\n */\n/**\n * Replaces all properties on any type as optional, includes nested types\n *\n * @example\n * ```ts\n * interface Person {\n *  name: string;\n *  age?: number;\n *  spouse: Person;\n *  children: Person[];\n * }\n * type PartialPerson = RecursivePartial<Person>;\n * // results in\n * interface PartialPerson {\n *  name?: string;\n *  age?: number;\n *  spouse?: RecursivePartial<Person>;\n *  children?: RecursivePartial<Person>[]\n * }\n * ```\n */"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAIA,WAAW,GAAG,SAASA,WAAWA,CAACC,CAAC,EAAE;EAC/C,MAAM,IAAIC,KAAK,CAAC,mBAAmB,CAACC,MAAM,CAACF,CAAC,CAAC,CAAC;AAChD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,MAAMA,CAACC,GAAG,EAAE;EAC1B,OAAOC,MAAM,CAACC,IAAI,CAACF,GAAG,CAAC;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}
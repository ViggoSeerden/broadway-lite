{"ast":null,"code":"/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport { useImperativeHandle, useCallback } from 'react';\nexport var useImperativeGridRef = function useImperativeGridRef(_ref) {\n  var ref = _ref.ref,\n    gridRef = _ref.gridRef,\n    setIsFullScreen = _ref.setIsFullScreen,\n    focusContext = _ref.focusContext,\n    cellPopoverContext = _ref.cellPopoverContext,\n    sortedRowMap = _ref.sortingContext.sortedRowMap,\n    pagination = _ref.pagination,\n    rowCount = _ref.rowCount,\n    visibleColCount = _ref.visibleColCount;\n  // Cell location helpers\n  var _useCellLocationCheck = useCellLocationCheck(rowCount, visibleColCount),\n    checkCellExists = _useCellLocationCheck.checkCellExists;\n  var _useSortPageCheck = useSortPageCheck(pagination, sortedRowMap),\n    findVisibleRowIndex = _useSortPageCheck.findVisibleRowIndex;\n\n  // Focus APIs\n  var _setFocusedCell = focusContext.setFocusedCell; // eslint complains about the dependency array otherwise\n\n  // When we pass this API to the consumer, we can't know for sure that\n  // the targeted cell is valid or in view (unlike our internal state, where\n  // both of those states can be guaranteed), so we need to do some extra\n  // checks here to make sure the grid automatically handles all cells\n  var setFocusedCell = useCallback(function (_ref2) {\n    var rowIndex = _ref2.rowIndex,\n      colIndex = _ref2.colIndex;\n    checkCellExists({\n      rowIndex: rowIndex,\n      colIndex: colIndex\n    });\n    var visibleRowIndex = findVisibleRowIndex(rowIndex);\n    _setFocusedCell([colIndex, visibleRowIndex]); // Transmog args from obj to array\n  }, [_setFocusedCell, checkCellExists, findVisibleRowIndex]);\n\n  // Popover APIs\n  var _openCellPopover = cellPopoverContext.openCellPopover,\n    closeCellPopover = cellPopoverContext.closeCellPopover;\n\n  // When we pass this API to the consumer, we can't know for sure that\n  // the targeted cell is valid or in view (unlike our internal state, where\n  // both of those states can be guaranteed), so we need to do some extra\n  // checks here to make sure the grid automatically handles all cells\n  var openCellPopover = useCallback(function (_ref3) {\n    var rowIndex = _ref3.rowIndex,\n      colIndex = _ref3.colIndex;\n    checkCellExists({\n      rowIndex: rowIndex,\n      colIndex: colIndex\n    });\n    var visibleRowIndex = findVisibleRowIndex(rowIndex);\n    _openCellPopover({\n      rowIndex: visibleRowIndex,\n      colIndex: colIndex\n    });\n  }, [_openCellPopover, checkCellExists, findVisibleRowIndex]);\n  var scrollTo = useCallback(function () {\n    var _gridRef$current;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return (_gridRef$current = gridRef.current) === null || _gridRef$current === void 0 ? void 0 : _gridRef$current.scrollTo.apply(_gridRef$current, args);\n  }, [gridRef]);\n  var scrollToItem = useCallback(function () {\n    var _gridRef$current2;\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return (_gridRef$current2 = gridRef.current) === null || _gridRef$current2 === void 0 ? void 0 : _gridRef$current2.scrollToItem.apply(_gridRef$current2, args);\n  }, [gridRef]);\n\n  // Set the ref APIs\n  useImperativeHandle(ref, function () {\n    return {\n      setIsFullScreen: setIsFullScreen,\n      setFocusedCell: setFocusedCell,\n      openCellPopover: openCellPopover,\n      closeCellPopover: closeCellPopover,\n      scrollTo: scrollTo,\n      scrollToItem: scrollToItem\n    };\n  }, [setIsFullScreen, setFocusedCell, openCellPopover, closeCellPopover, scrollTo, scrollToItem]);\n};\n\n/**\n * Throw a digestible error if the consumer attempts to focus into an invalid\n * cell range, which should also stop the APIs from continuing\n */\nexport var useCellLocationCheck = function useCellLocationCheck(rowCount, colCount) {\n  var checkCellExists = useCallback(function (_ref4) {\n    var rowIndex = _ref4.rowIndex,\n      colIndex = _ref4.colIndex;\n    if (rowIndex >= rowCount || rowIndex < 0) {\n      throw new Error(\"Row \".concat(rowIndex, \" is not a valid row. The maximum visible row index is \").concat(rowCount - 1, \".\"));\n    }\n    if (colIndex >= colCount) {\n      throw new Error(\"Column \".concat(colIndex, \" is not a valid column. The maximum visible column index is \").concat(colCount - 1, \".\"));\n    }\n  }, [rowCount, colCount]);\n  return {\n    checkCellExists: checkCellExists\n  };\n};\n\n/**\n * The rowIndex passed from the consumer is the unsorted and unpaginated\n * index derived from their original data. We need to convert that rowIndex\n * into a visibleRowIndex (which is what our internal cell APIs use) and, if\n * the row is not on the current page, the grid should automatically handle\n * paginating to that row.\n */\nexport var useSortPageCheck = function useSortPageCheck(pagination, sortedRowMap) {\n  var findVisibleRowIndex = useCallback(function (rowIndex) {\n    // Account for sorting\n    var visibleRowIndex = sortedRowMap.length ? sortedRowMap.findIndex(function (mappedIndex) {\n      return mappedIndex === rowIndex;\n    }) : rowIndex;\n\n    // Account for pagination\n    if (pagination && pagination.pageSize > 0) {\n      var pageIndex = Math.floor(visibleRowIndex / pagination.pageSize);\n      // If the targeted row is on a different page than the current page,\n      // we should automatically navigate the user to the correct page\n      if (pageIndex !== pagination.pageIndex) {\n        pagination.onChangePage(pageIndex);\n      }\n      // Get the row's visible row index on that page\n      return visibleRowIndex % pagination.pageSize;\n    }\n    return visibleRowIndex;\n  }, [pagination, sortedRowMap]);\n  return {\n    findVisibleRowIndex: findVisibleRowIndex\n  };\n};","map":{"version":3,"names":["useImperativeHandle","useCallback","useImperativeGridRef","_ref","ref","gridRef","setIsFullScreen","focusContext","cellPopoverContext","sortedRowMap","sortingContext","pagination","rowCount","visibleColCount","_useCellLocationCheck","useCellLocationCheck","checkCellExists","_useSortPageCheck","useSortPageCheck","findVisibleRowIndex","_setFocusedCell","setFocusedCell","_ref2","rowIndex","colIndex","visibleRowIndex","_openCellPopover","openCellPopover","closeCellPopover","_ref3","scrollTo","_gridRef$current","_len","arguments","length","args","Array","_key","current","apply","scrollToItem","_gridRef$current2","_len2","_key2","colCount","_ref4","Error","concat","findIndex","mappedIndex","pageSize","pageIndex","Math","floor","onChangePage"],"sources":["/home/runner/work/broadway-lite/broadway-lite/node_modules/@elastic/eui/es/components/datagrid/utils/ref.js"],"sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport { useImperativeHandle, useCallback } from 'react';\nexport var useImperativeGridRef = function useImperativeGridRef(_ref) {\n  var ref = _ref.ref,\n    gridRef = _ref.gridRef,\n    setIsFullScreen = _ref.setIsFullScreen,\n    focusContext = _ref.focusContext,\n    cellPopoverContext = _ref.cellPopoverContext,\n    sortedRowMap = _ref.sortingContext.sortedRowMap,\n    pagination = _ref.pagination,\n    rowCount = _ref.rowCount,\n    visibleColCount = _ref.visibleColCount;\n  // Cell location helpers\n  var _useCellLocationCheck = useCellLocationCheck(rowCount, visibleColCount),\n    checkCellExists = _useCellLocationCheck.checkCellExists;\n  var _useSortPageCheck = useSortPageCheck(pagination, sortedRowMap),\n    findVisibleRowIndex = _useSortPageCheck.findVisibleRowIndex;\n\n  // Focus APIs\n  var _setFocusedCell = focusContext.setFocusedCell; // eslint complains about the dependency array otherwise\n\n  // When we pass this API to the consumer, we can't know for sure that\n  // the targeted cell is valid or in view (unlike our internal state, where\n  // both of those states can be guaranteed), so we need to do some extra\n  // checks here to make sure the grid automatically handles all cells\n  var setFocusedCell = useCallback(function (_ref2) {\n    var rowIndex = _ref2.rowIndex,\n      colIndex = _ref2.colIndex;\n    checkCellExists({\n      rowIndex: rowIndex,\n      colIndex: colIndex\n    });\n    var visibleRowIndex = findVisibleRowIndex(rowIndex);\n    _setFocusedCell([colIndex, visibleRowIndex]); // Transmog args from obj to array\n  }, [_setFocusedCell, checkCellExists, findVisibleRowIndex]);\n\n  // Popover APIs\n  var _openCellPopover = cellPopoverContext.openCellPopover,\n    closeCellPopover = cellPopoverContext.closeCellPopover;\n\n  // When we pass this API to the consumer, we can't know for sure that\n  // the targeted cell is valid or in view (unlike our internal state, where\n  // both of those states can be guaranteed), so we need to do some extra\n  // checks here to make sure the grid automatically handles all cells\n  var openCellPopover = useCallback(function (_ref3) {\n    var rowIndex = _ref3.rowIndex,\n      colIndex = _ref3.colIndex;\n    checkCellExists({\n      rowIndex: rowIndex,\n      colIndex: colIndex\n    });\n    var visibleRowIndex = findVisibleRowIndex(rowIndex);\n    _openCellPopover({\n      rowIndex: visibleRowIndex,\n      colIndex: colIndex\n    });\n  }, [_openCellPopover, checkCellExists, findVisibleRowIndex]);\n  var scrollTo = useCallback(function () {\n    var _gridRef$current;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return (_gridRef$current = gridRef.current) === null || _gridRef$current === void 0 ? void 0 : _gridRef$current.scrollTo.apply(_gridRef$current, args);\n  }, [gridRef]);\n  var scrollToItem = useCallback(function () {\n    var _gridRef$current2;\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return (_gridRef$current2 = gridRef.current) === null || _gridRef$current2 === void 0 ? void 0 : _gridRef$current2.scrollToItem.apply(_gridRef$current2, args);\n  }, [gridRef]);\n\n  // Set the ref APIs\n  useImperativeHandle(ref, function () {\n    return {\n      setIsFullScreen: setIsFullScreen,\n      setFocusedCell: setFocusedCell,\n      openCellPopover: openCellPopover,\n      closeCellPopover: closeCellPopover,\n      scrollTo: scrollTo,\n      scrollToItem: scrollToItem\n    };\n  }, [setIsFullScreen, setFocusedCell, openCellPopover, closeCellPopover, scrollTo, scrollToItem]);\n};\n\n/**\n * Throw a digestible error if the consumer attempts to focus into an invalid\n * cell range, which should also stop the APIs from continuing\n */\nexport var useCellLocationCheck = function useCellLocationCheck(rowCount, colCount) {\n  var checkCellExists = useCallback(function (_ref4) {\n    var rowIndex = _ref4.rowIndex,\n      colIndex = _ref4.colIndex;\n    if (rowIndex >= rowCount || rowIndex < 0) {\n      throw new Error(\"Row \".concat(rowIndex, \" is not a valid row. The maximum visible row index is \").concat(rowCount - 1, \".\"));\n    }\n    if (colIndex >= colCount) {\n      throw new Error(\"Column \".concat(colIndex, \" is not a valid column. The maximum visible column index is \").concat(colCount - 1, \".\"));\n    }\n  }, [rowCount, colCount]);\n  return {\n    checkCellExists: checkCellExists\n  };\n};\n\n/**\n * The rowIndex passed from the consumer is the unsorted and unpaginated\n * index derived from their original data. We need to convert that rowIndex\n * into a visibleRowIndex (which is what our internal cell APIs use) and, if\n * the row is not on the current page, the grid should automatically handle\n * paginating to that row.\n */\nexport var useSortPageCheck = function useSortPageCheck(pagination, sortedRowMap) {\n  var findVisibleRowIndex = useCallback(function (rowIndex) {\n    // Account for sorting\n    var visibleRowIndex = sortedRowMap.length ? sortedRowMap.findIndex(function (mappedIndex) {\n      return mappedIndex === rowIndex;\n    }) : rowIndex;\n\n    // Account for pagination\n    if (pagination && pagination.pageSize > 0) {\n      var pageIndex = Math.floor(visibleRowIndex / pagination.pageSize);\n      // If the targeted row is on a different page than the current page,\n      // we should automatically navigate the user to the correct page\n      if (pageIndex !== pagination.pageIndex) {\n        pagination.onChangePage(pageIndex);\n      }\n      // Get the row's visible row index on that page\n      return visibleRowIndex % pagination.pageSize;\n    }\n    return visibleRowIndex;\n  }, [pagination, sortedRowMap]);\n  return {\n    findVisibleRowIndex: findVisibleRowIndex\n  };\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
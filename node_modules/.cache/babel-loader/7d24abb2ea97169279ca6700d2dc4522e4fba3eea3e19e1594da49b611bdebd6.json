{"ast":null,"code":"/*jslint node: true*/\nvar toArray = require('lodash/toArray');\nvar emojiByName = require('./emoji.json');\n\"use strict\";\n\n/**\n * regex to parse emoji in a string - finds emoji, e.g. :coffee:\n */\nvar emojiNameRegex = /:([a-zA-Z0-9_\\-\\+]+):/g;\n\n/**\n * regex to trim whitespace\n * use instead of String.prototype.trim() for IE8 support\n */\nvar trimSpaceRegex = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\n/**\n * Removes colons on either side\n * of the string if present\n * @param  {string} str\n * @return {string}\n */\nfunction stripColons(str) {\n  var colonIndex = str.indexOf(':');\n  if (colonIndex > -1) {\n    // :emoji: (http://www.emoji-cheat-sheet.com/)\n    if (colonIndex === str.length - 1) {\n      str = str.substring(0, colonIndex);\n      return stripColons(str);\n    } else {\n      str = str.substr(colonIndex + 1);\n      return stripColons(str);\n    }\n  }\n  return str;\n}\n\n/**\n * Adds colons to either side\n * of the string\n * @param {string} str\n * @return {string}\n */\nfunction wrapColons(str) {\n  return typeof str === 'string' && str.length > 0 ? ':' + str + ':' : str;\n}\n\n/**\n * Ensure that the word is wrapped in colons\n * by only adding them, if they are not there.\n * @param {string} str\n * @return {string}\n */\nfunction ensureColons(str) {\n  return typeof str === 'string' && str[0] !== ':' ? wrapColons(str) : str;\n}\n\n// Non spacing mark, some emoticons have them. It's the 'Variant Form',\n// which provides more information so that emoticons can be rendered as\n// more colorful graphics. FE0E is a unicode text version, where as FE0F\n// should be rendered as a graphical version. The code gracefully degrades.\nvar NON_SPACING_MARK = String.fromCharCode(65039); // 65039 - '️' - 0xFE0F;\nvar nonSpacingRegex = new RegExp(NON_SPACING_MARK, 'g');\n\n// Remove the non-spacing-mark from the code, never send a stripped version\n// to the client, as it kills graphical emoticons.\nfunction stripNSB(code) {\n  return code.replace(nonSpacingRegex, '');\n}\n;\n\n// Reversed hash table, where as emojiByName contains a { heart: '❤' }\n// dictionary emojiByCode contains { ❤: 'heart' }. The codes are normalized\n// to the text version.\nvar emojiByCode = Object.keys(emojiByName).reduce(function (h, k) {\n  h[stripNSB(emojiByName[k])] = k;\n  return h;\n}, {});\n\n/**\n * Emoji namespace\n */\nvar Emoji = {\n  emoji: emojiByName\n};\n\n/**\n * get emoji code from name. return emoji code back if code is passed in.\n * @param  {string} emoji\n * @return {string}\n */\nEmoji._get = function _get(emoji) {\n  if (emojiByCode[stripNSB(emoji)]) {\n    return emoji;\n  } else if (emojiByName.hasOwnProperty(emoji)) {\n    return emojiByName[emoji];\n  }\n  return ensureColons(emoji);\n};\n\n/**\n * get emoji code from :emoji: string or name\n * @param  {string} emoji\n * @return {string}\n */\nEmoji.get = function get(emoji) {\n  emoji = stripColons(emoji);\n  return Emoji._get(emoji);\n};\n\n/**\n * find the emoji by either code or name\n * @param {string} nameOrCode The emoji to find, either `coffee`, `:coffee:` or `☕`;\n * @return {object}\n */\nEmoji.find = function find(nameOrCode) {\n  return Emoji.findByName(nameOrCode) || Emoji.findByCode(nameOrCode);\n};\n\n/**\n * find the emoji by name\n * @param {string} name The emoji to find either `coffee` or `:coffee:`;\n * @return {object}\n */\nEmoji.findByName = function findByName(name) {\n  var stripped = stripColons(name);\n  var emoji = emojiByName[stripped];\n  return emoji ? {\n    emoji: emoji,\n    key: stripped\n  } : undefined;\n};\n\n/**\n * find the emoji by code (emoji)\n * @param {string} code The emoji to find; for example `☕` or `☔`\n * @return {object}\n */\nEmoji.findByCode = function findByCode(code) {\n  var stripped = stripNSB(code);\n  var name = emojiByCode[stripped];\n\n  // lookup emoji to ensure the Variant Form is returned\n  return name ? {\n    emoji: emojiByName[name],\n    key: name\n  } : undefined;\n};\n\n/**\n * Check if an emoji is known by this library\n * @param {string} nameOrCode The emoji to validate, either `coffee`, `:coffee:` or `☕`;\n * @return {object}\n */\nEmoji.hasEmoji = function hasEmoji(nameOrCode) {\n  return Emoji.hasEmojiByName(nameOrCode) || Emoji.hasEmojiByCode(nameOrCode);\n};\n\n/**\n * Check if an emoji with given name is known by this library\n * @param {string} name The emoji to validate either `coffee` or `:coffee:`;\n * @return {object}\n */\nEmoji.hasEmojiByName = function hasEmojiByName(name) {\n  var result = Emoji.findByName(name);\n  return !!result && result.key === stripColons(name);\n};\n\n/**\n * Check if a given emoji is known by this library\n * @param {string} code The emoji to validate; for example `☕` or `☔`\n * @return {object}\n */\nEmoji.hasEmojiByCode = function hasEmojiByCode(code) {\n  var result = Emoji.findByCode(code);\n  return !!result && stripNSB(result.emoji) === stripNSB(code);\n};\n\n/**\n * get emoji name from code\n * @param  {string} emoji\n * @param  {boolean} includeColons should the result include the ::\n * @return {string}\n */\nEmoji.which = function which(emoji_code, includeColons) {\n  var code = stripNSB(emoji_code);\n  var word = emojiByCode[code];\n  return includeColons ? wrapColons(word) : word;\n};\n\n/**\n * emojify a string (replace :emoji: with an emoji)\n * @param  {string} str\n * @param  {function} on_missing (gets emoji name without :: and returns a proper emoji if no emoji was found)\n * @param  {function} format (wrap the returned emoji in a custom element)\n * @return {string}\n */\nEmoji.emojify = function emojify(str, on_missing, format) {\n  if (!str) return '';\n  return str.split(emojiNameRegex) // parse emoji via regex\n  .map(function parseEmoji(s, i) {\n    // every second element is an emoji, e.g. \"test :fast_forward:\" -> [ \"test \", \"fast_forward\" ]\n    if (i % 2 === 0) return s;\n    var emoji = Emoji._get(s);\n    var isMissing = emoji.indexOf(':') > -1;\n    if (isMissing && typeof on_missing === 'function') {\n      return on_missing(s);\n    }\n    if (!isMissing && typeof format === 'function') {\n      return format(emoji, s);\n    }\n    return emoji;\n  }).join('') // convert back to string\n  ;\n};\n\n/**\n * return a random emoji\n * @return {string}\n */\nEmoji.random = function random() {\n  var emojiKeys = Object.keys(emojiByName);\n  var randomIndex = Math.floor(Math.random() * emojiKeys.length);\n  var key = emojiKeys[randomIndex];\n  var emoji = Emoji._get(key);\n  return {\n    key: key,\n    emoji: emoji\n  };\n};\n\n/**\n *  return an collection of potential emoji matches\n *  @param {string} str\n *  @return {Array.<Object>}\n */\nEmoji.search = function search(str) {\n  var emojiKeys = Object.keys(emojiByName);\n  var matcher = stripColons(str);\n  var matchingKeys = emojiKeys.filter(function (key) {\n    return key.toString().indexOf(matcher) === 0;\n  });\n  return matchingKeys.map(function (key) {\n    return {\n      key: key,\n      emoji: Emoji._get(key)\n    };\n  });\n};\n\n/**\n * unemojify a string (replace emoji with :emoji:)\n * @param  {string} str\n * @return {string}\n */\nEmoji.unemojify = function unemojify(str) {\n  if (!str) return '';\n  var words = toArray(str);\n  return words.map(function (word) {\n    return Emoji.which(word, true) || word;\n  }).join('');\n};\n\n/**\n * replace emojis with replacement value\n * @param {string} str\n * @param {function|string} the string or callback function to replace the emoji with\n * @param {boolean} should trailing whitespaces be cleaned? Defaults false\n * @return {string}\n */\nEmoji.replace = function replace(str, replacement, cleanSpaces) {\n  if (!str) return '';\n  var replace = typeof replacement === 'function' ? replacement : function () {\n    return replacement;\n  };\n  var words = toArray(str);\n  var replaced = words.map(function (word, idx) {\n    var emoji = Emoji.findByCode(word);\n    if (emoji && cleanSpaces && words[idx + 1] === ' ') {\n      words[idx + 1] = '';\n    }\n    return emoji ? replace(emoji) : word;\n  }).join('');\n  return cleanSpaces ? replaced.replace(trimSpaceRegex, '') : replaced;\n};\n\n/**\n * remove all emojis from a string\n * @param {string} str\n * @return {string}\n */\nEmoji.strip = function strip(str) {\n  return Emoji.replace(str, '', true);\n};\nmodule.exports = Emoji;","map":{"version":3,"names":["toArray","require","emojiByName","emojiNameRegex","trimSpaceRegex","stripColons","str","colonIndex","indexOf","length","substring","substr","wrapColons","ensureColons","NON_SPACING_MARK","String","fromCharCode","nonSpacingRegex","RegExp","stripNSB","code","replace","emojiByCode","Object","keys","reduce","h","k","Emoji","emoji","_get","hasOwnProperty","get","find","nameOrCode","findByName","findByCode","name","stripped","key","undefined","hasEmoji","hasEmojiByName","hasEmojiByCode","result","which","emoji_code","includeColons","word","emojify","on_missing","format","split","map","parseEmoji","s","i","isMissing","join","random","emojiKeys","randomIndex","Math","floor","search","matcher","matchingKeys","filter","toString","unemojify","words","replacement","cleanSpaces","replaced","idx","strip","module","exports"],"sources":["/home/runner/work/broadway-lite/broadway-lite/node_modules/node-emoji/lib/emoji.js"],"sourcesContent":["/*jslint node: true*/\nvar toArray = require('lodash/toArray');\nvar emojiByName = require('./emoji.json');\n\n\"use strict\";\n\n/**\n * regex to parse emoji in a string - finds emoji, e.g. :coffee:\n */\nvar emojiNameRegex = /:([a-zA-Z0-9_\\-\\+]+):/g;\n\n/**\n * regex to trim whitespace\n * use instead of String.prototype.trim() for IE8 support\n */\nvar trimSpaceRegex = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\n/**\n * Removes colons on either side\n * of the string if present\n * @param  {string} str\n * @return {string}\n */\nfunction stripColons (str) {\n  var colonIndex = str.indexOf(':');\n  if (colonIndex > -1) {\n    // :emoji: (http://www.emoji-cheat-sheet.com/)\n    if (colonIndex === str.length - 1) {\n      str = str.substring(0, colonIndex);\n      return stripColons(str);\n    } else {\n      str = str.substr(colonIndex + 1);\n      return stripColons(str);\n    }\n  }\n\n  return str;\n}\n\n/**\n * Adds colons to either side\n * of the string\n * @param {string} str\n * @return {string}\n */\nfunction wrapColons (str) {\n  return (typeof str === 'string' && str.length > 0) ? ':' + str + ':' : str;\n}\n\n/**\n * Ensure that the word is wrapped in colons\n * by only adding them, if they are not there.\n * @param {string} str\n * @return {string}\n */\nfunction ensureColons (str) {\n  return (typeof str === 'string' && str[0] !== ':') ? wrapColons(str) : str;\n}\n\n// Non spacing mark, some emoticons have them. It's the 'Variant Form',\n// which provides more information so that emoticons can be rendered as\n// more colorful graphics. FE0E is a unicode text version, where as FE0F\n// should be rendered as a graphical version. The code gracefully degrades.\nvar NON_SPACING_MARK = String.fromCharCode(65039); // 65039 - '️' - 0xFE0F;\nvar nonSpacingRegex = new RegExp(NON_SPACING_MARK, 'g')\n\n// Remove the non-spacing-mark from the code, never send a stripped version\n// to the client, as it kills graphical emoticons.\nfunction stripNSB (code) {\n  return code.replace(nonSpacingRegex, '');\n};\n\n// Reversed hash table, where as emojiByName contains a { heart: '❤' }\n// dictionary emojiByCode contains { ❤: 'heart' }. The codes are normalized\n// to the text version.\nvar emojiByCode = Object.keys(emojiByName).reduce(function(h,k) {\n  h[stripNSB(emojiByName[k])] = k;\n  return h;\n}, {});\n\n/**\n * Emoji namespace\n */\nvar Emoji = {\n  emoji: emojiByName,\n};\n\n/**\n * get emoji code from name. return emoji code back if code is passed in.\n * @param  {string} emoji\n * @return {string}\n */\nEmoji._get = function _get (emoji) {\n  if (emojiByCode[stripNSB(emoji)]) {\n    return emoji;\n  } else if (emojiByName.hasOwnProperty(emoji)) {\n    return emojiByName[emoji];\n  }\n\n  return ensureColons(emoji);\n};\n\n/**\n * get emoji code from :emoji: string or name\n * @param  {string} emoji\n * @return {string}\n */\nEmoji.get = function get (emoji) {\n  emoji = stripColons(emoji);\n\n  return Emoji._get(emoji);\n};\n\n/**\n * find the emoji by either code or name\n * @param {string} nameOrCode The emoji to find, either `coffee`, `:coffee:` or `☕`;\n * @return {object}\n */\nEmoji.find = function find (nameOrCode) {\n  return Emoji.findByName(nameOrCode) || Emoji.findByCode(nameOrCode);\n};\n\n/**\n * find the emoji by name\n * @param {string} name The emoji to find either `coffee` or `:coffee:`;\n * @return {object}\n */\nEmoji.findByName = function findByName (name) {\n  var stripped = stripColons(name);\n  var emoji = emojiByName[stripped];\n\n  return emoji ? ({ emoji: emoji, key: stripped }) : undefined;\n};\n\n/**\n * find the emoji by code (emoji)\n * @param {string} code The emoji to find; for example `☕` or `☔`\n * @return {object}\n */\nEmoji.findByCode = function findByCode (code) {\n  var stripped = stripNSB(code);\n  var name = emojiByCode[stripped];\n\n  // lookup emoji to ensure the Variant Form is returned\n  return name ? ({ emoji: emojiByName[name], key: name }) : undefined;\n};\n\n\n/**\n * Check if an emoji is known by this library\n * @param {string} nameOrCode The emoji to validate, either `coffee`, `:coffee:` or `☕`;\n * @return {object}\n */\nEmoji.hasEmoji = function hasEmoji (nameOrCode) {\n  return Emoji.hasEmojiByName(nameOrCode) || Emoji.hasEmojiByCode(nameOrCode);\n};\n\n/**\n * Check if an emoji with given name is known by this library\n * @param {string} name The emoji to validate either `coffee` or `:coffee:`;\n * @return {object}\n */\nEmoji.hasEmojiByName = function hasEmojiByName (name) {\n  var result = Emoji.findByName(name);\n  return !!result && result.key === stripColons(name);\n};\n\n/**\n * Check if a given emoji is known by this library\n * @param {string} code The emoji to validate; for example `☕` or `☔`\n * @return {object}\n */\nEmoji.hasEmojiByCode = function hasEmojiByCode (code) {\n  var result = Emoji.findByCode(code);\n  return !!result && stripNSB(result.emoji) === stripNSB(code);\n};\n\n/**\n * get emoji name from code\n * @param  {string} emoji\n * @param  {boolean} includeColons should the result include the ::\n * @return {string}\n */\nEmoji.which = function which (emoji_code, includeColons) {\n  var code = stripNSB(emoji_code);\n  var word = emojiByCode[code];\n\n  return includeColons ? wrapColons(word) : word;\n};\n\n/**\n * emojify a string (replace :emoji: with an emoji)\n * @param  {string} str\n * @param  {function} on_missing (gets emoji name without :: and returns a proper emoji if no emoji was found)\n * @param  {function} format (wrap the returned emoji in a custom element)\n * @return {string}\n */\nEmoji.emojify = function emojify (str, on_missing, format) {\n  if (!str) return '';\n\n  return str.split(emojiNameRegex) // parse emoji via regex\n            .map(function parseEmoji(s, i) {\n              // every second element is an emoji, e.g. \"test :fast_forward:\" -> [ \"test \", \"fast_forward\" ]\n              if (i % 2 === 0) return s;\n              var emoji = Emoji._get(s);\n              var isMissing = emoji.indexOf(':') > -1;\n\n              if (isMissing && typeof on_missing === 'function') {\n                return on_missing(s);\n              }\n\n              if (!isMissing && typeof format === 'function') {\n                return format(emoji, s);\n              }\n\n              return emoji;\n            })\n            .join('') // convert back to string\n  ;\n};\n\n/**\n * return a random emoji\n * @return {string}\n */\nEmoji.random = function random () {\n  var emojiKeys = Object.keys(emojiByName);\n  var randomIndex = Math.floor(Math.random() * emojiKeys.length);\n  var key = emojiKeys[randomIndex];\n  var emoji = Emoji._get(key);\n  return { key: key, emoji: emoji };\n}\n\n/**\n *  return an collection of potential emoji matches\n *  @param {string} str\n *  @return {Array.<Object>}\n */\nEmoji.search = function search (str) {\n  var emojiKeys = Object.keys(emojiByName);\n  var matcher = stripColons(str)\n  var matchingKeys = emojiKeys.filter(function(key) {\n    return key.toString().indexOf(matcher) === 0;\n  });\n  return matchingKeys.map(function(key) {\n    return {\n      key: key,\n      emoji: Emoji._get(key),\n    };\n  });\n}\n\n/**\n * unemojify a string (replace emoji with :emoji:)\n * @param  {string} str\n * @return {string}\n */\nEmoji.unemojify = function unemojify (str) {\n  if (!str) return '';\n  var words = toArray(str);\n\n  return words.map(function(word) {\n    return Emoji.which(word, true) || word;\n  }).join('');\n};\n\n/**\n * replace emojis with replacement value\n * @param {string} str\n * @param {function|string} the string or callback function to replace the emoji with\n * @param {boolean} should trailing whitespaces be cleaned? Defaults false\n * @return {string}\n */\nEmoji.replace = function replace (str, replacement, cleanSpaces) {\n  if (!str) return '';\n\n  var replace = typeof replacement === 'function' ? replacement : function() { return replacement; };\n  var words = toArray(str);\n\n  var replaced = words.map(function(word, idx) {\n    var emoji = Emoji.findByCode(word);\n\n    if (emoji && cleanSpaces && words[idx + 1] === ' ') {\n      words[idx + 1] = '';\n    }\n\n    return emoji ? replace(emoji) : word;\n  }).join('');\n\n  return cleanSpaces ? replaced.replace(trimSpaceRegex, '') : replaced;\n};\n\n\n/**\n * remove all emojis from a string\n * @param {string} str\n * @return {string}\n */\nEmoji.strip = function strip (str) {\n  return Emoji.replace(str, '', true);\n};\n\nmodule.exports = Emoji;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}